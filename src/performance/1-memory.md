---
title: 内存优化
order: 1
category: false
tag:
  - JS性能优化
  - 内存管理
  - 垃圾回收
---

## 垃圾回收

JS 中的内存管理遵循：申请内存空间 -> 使用内存空间 -> 释放内存空间 的顺序

垃圾回收机制：

1. JS 自动进行内存管理
2. 对象不再被引用时就是垃圾
3. 对象不能从根（全局变量对象）上访问的时候就是垃圾

下面的垃圾回收算法都按照这个机制执行垃圾回收

### 垃圾回收(GC)算法

GC 可以找到内存中的垃圾，并释放和回收空间

优点：

- 发现垃圾立即回收
- 最大限度地减少程序暂停

缺点：

- 循环引用对象无法回收
- 时间开销大（时刻维护对象的引用）

常用的 GC 算法如下。

### 引用计数

维护一个引用计数器，判断当前引用数是否为 0

引用数字为 0 的时候立即回收

互相引用的对象无法被回收

优缺点：

- 可以即时回收垃圾对象
- 减少程序卡顿时间
- 无法回收循环引用的对象
- 资源消耗较大

### 标记清除

分标记阶段和清除阶段两个阶段

遍历所有对象找标记活动对象

遍历所有对象清除没有标记对象

回收相应空间

优缺点：

- 相对于引用计数，可以回收循环引用但没有用处的对象
- 内存空间地址不连续、空间碎片化，由于回收的对象在本来的地址也是不连续的，就会导致回收的对象地址也是不连续的，浪费空间
- 不会立即回收垃圾对象

### 标记整理

标记清除的增强版

标记阶段的操作和标记清除一致

**清除阶段会先执行整理，移动对象位置**，重点就是这个整理，标记清除就是因为回收的对象的地址不连续，导致碎片空间化。而标记整理会在清除前，先整理一遍，将活动的对象移动到一起，需要回收的对象移动到一起，这样回收的时候，回收对象的地址就是连续的。

优缺点：

- 减少碎片化空间
- 不会立即回收垃圾对象

## V8 垃圾回收策略

V8 引擎采用的是分代回收

内存分为新生代存储区和老生代存储区，针对不同的对象采用不同的算法

V8 中常用的 GC：**分代回收、空间复制、标记清除、标记整理、标记增量**

### 新生代处理

#### 新生代对象回收

V8 将内存空间一分为二

小空间用于存储新生代对象（32M | 16M）

新生代对象指的是存活时间较短的对象

#### 新生代对象回收实现

回收过程采用复制算法+标记整理

新生代内存区分为两个等大小空间

使用空间为 from，空闲空间为 to

活动对象存储于 from 空间

标记整理后将活动对象拷贝至 to 空间

from 与 to 交换空间完成释放

#### 回收细节说明

拷贝过程中可能出现晋升

晋升就是将新生代对象移动至老生代

一轮 GC 还存活的新生代就需要晋升

to 空间的使用率超过 25%

### 老生代处理

#### 