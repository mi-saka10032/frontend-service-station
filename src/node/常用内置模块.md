---
title: 常用内置模块
order: 3
category: false
tag:
  - Node
  - 内置模块
  - API
---

## path

path 模块用于对路径和文件进行处理，提供了很多好用的方法。

主要因为 Mac OS、Linux 和 windows 上的路径写法不一样

在window 上会使用 \或者 \\ 来作为文件路径的分隔符，当然目前也支持 /

在 Mac OS、Linux 的 Unix 操作系统上使用 / 来作为文件路径的分隔符

为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块

### 可移植操作系统接口

Portable Operating System Interface，缩写为 POSIX

Linux 和 Mac OS 都实现了 POSIX 接口；

Window 部分电脑实现了 POSIX 接口；

### 获取路径信息

dirname：获取文件的父文件夹；

basename：获取文件名；

extname：获取文件扩展名；

### 路径拼接

如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符

这时候可以使用 path.join 函数

### 将文件和某个文件夹拼接

如果我们希望将某个文件和文件夹拼接，可以使用 path.resolve;

resolve 函数会判断我们拼接的路径前面是否有 /或../或./；

如果有表示是一个绝对路径，会返回对应的拼接路径；如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接

在 webpack 中获取路径或者起别名的地方也可以使用。

## fs

### File System 文件系统

借助于 Node 帮我们封装的文件系统，我们可以在任何的操作系统（window、Mac OS、Linux）上面直接去操作文件；

这也是 Node 可以开发服务器的一大原因，也是它可以成为前端自动化脚本等热门工具的原因。

Node 的 API 大多数都提供三种操作方式：

方法1：同步操作文件：代码会被阻塞，不会继续执行；

方法2：异步回调函数操作文件：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行；

方法3：异步 Promise 操作文件：代码不会被阻塞，通过 fs.promises 调用方法操作，会返回一个 Promise，可以通过 then、catch 进行处理。

### File Descriptors 文件描述符

在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。

每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。

在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。

Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。

最终，为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。

### fs.open()

用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息。

```js
fs.open("../foo.txt", "r", (err, fd) => {
  console.log(fd);
  fs.fstat(fd, (err, state) => {
    console.log(state);
  });
});
```

- 参数 1：文件路径，String 类型

- 参数 2：文件打开模式 options.flag 'r' 'w' ...

- 参数 3：callback 回调函数

详细描述见 Node 官方文档

### fs 读写

fs.readFile(path[, options], callback)：读取文件的内容；

fs.writeFile(file, data[, options], callback)：在文件中写入内容；

#### options.flag

w 打开文件写入，默认值；

w+打开文件进行读写，如果不存在则创建文件；

r+ 打开文件进行读写，如果不存在那么抛出异常；

r 打开文件读取，读取时的默认值；

a 打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；

a+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件

#### options.encoding

最常用 UTF-8 编码

文件读取 readFile 中，如果不填写 encoding，返回的结果是 Buffer。

### fs 操作文件夹

fs.mkdir() fs.mkdirSync() 创建新文件夹

#### 读取文件夹内容

```js
fs.readdir(dirname, (err, files) => {
  console.log(files);
});
```

将目录中读取到的文件名称转为 files 数组

#### 文件夹重命名

```js
fs.rename("../old", "../new", (err) => {
  console.log(err);
});
```

#### 文件夹复制

```js
fs.copyFile(srcFile, destFile);
```

## Events

Node 中的核心 API 都是基于异步事件驱动的

某些对象（发射器（Emitters））发出某一个事件；

监听这个事件（监听器 Listeners），并且传入的回调函数，这个回调函数会在监听到事件时调用；

发出事件和监听事件都是通过**EventEmitter 类**来完成的，它们都属于 events 对象。

`emitter.on(eventName, listener)`：监听事件，也可以使用 addListener；

`emitter.off(eventName, listener)`：移除事件监听，也可以使用 removeListener；

`emitter.emit(eventName[, ...args])`：发出事件，可以携带一些参数；

### 常见属性

`emitter.eventNames()`： 返回当前 EventEmitter 对象注册的事件字符串数组；

`emitter.getMaxListeners()`： 返回当前 EventEmitter 对象的最大监听器数量，可以通过 setMaxListeners()来修改，默认是 10；

`emitter.listenerCount(事件名称)`： 返回当前 EventEmitter 对象某一个事件名称，监听器的个数；

`emitter.listeners(事件名称)`：返回当前 EventEmitter 对象某个事件监听器上所有的监听器数组。

### 方法补充

`emitter.once(eventName, listener)`：事件监听一次

`emitter.prependListener()`：将监听事件添加到最前面

`emitter.prependOnceListener()`：将监听事件添加到最前面，但是只监听一次

`emitter.removeAllListeners([eventName])`：移除所有的监听器
