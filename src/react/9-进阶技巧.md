---
title: 进阶技巧
order: 9
category: false
tag:
  - 进阶技巧
  - 扩展API
  - 性能优化
---

## 懒加载`lazy`

`React.lazy` 函数可以动态引入组件

`React.suspense` 支持组件等待加载完成前的加载过程中操作如：loading 加载中... 显示

### 语法

`const OtherComponent = React.lazy(() => import('./OtherComponent'));`

```jsx
import React, { Suspense } from "react";

const OtherComponent = React.lazy(() => import("./OtherComponent"));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

fallback 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Suspense 组件包裹多个懒加载组件。

```jsx
import React, { Suspense } from "react";

const OtherComponent = React.lazy(() => import("./OtherComponent"));
const AnotherComponent = React.lazy(() => import("./AnotherComponent"));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}
```

### 过渡效果

```jsx
import React, { Suspense, startTransition } from "react";
import Tabs from "./Tabs";
import Glimmer from "./Glimmer";

const Comments = React.lazy(() => import("./Comments"));
const Photos = React.lazy(() => import("./Photos"));

function MyComponent() {
  const [tab, setTab] = React.useState("photos");

  function handleTabSelect(tab) {
    startTransition(() => {
      setTab(tab);
    });
  }

  return (
    <div>
      <Tabs onTabSelect={handleTabSelect} />
      <Suspense fallback={<Glimmer />}>
        {tab === "photos" ? <Photos /> : <Comments />}
      </Suspense>
    </div>
  );
}
```

当 tab 切换时，标签切换为"comments"不会标记为紧急更新，而是标记为需要一些准备时间的 transition，实现一个过渡效果。React 会保留旧的 UI 并进行交互，当它准备好时，会切换为 Comments 组件

## Context

Context 实现了祖孙组件之间的通信，类似于 Vue 中的 provide 与 inject

Hook 函数式组件的 context 写法详见[useContext](./8-hook.html#祖孙环境-hookcontext-hook)

### 使用时机与考虑

Context 设计目的是为了共享自上而下的组件树中的“全局”数据，例如登录认证用户信息、主题或语言等

Context 主要应用于很多不同层级的组件需要访问共享、共同使用、同步刷新的数据

使用时需要考虑组件的复用性，因为 Context 的引入会使复用性变差

### API

#### React.createContext

创建一个 Context 对象

`const MyContext = React.createContext(defaultValue);`

只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效

在组件中引入 MyContext 对象，并在 render 函数中使用`<MyContext.Provider></MyContext.Provider>`来开启订阅

**注意：**当组件没有捕获到来自于祖先组件的 Provider 时使用 MyContext，其默认值才会是 defaultValue

#### Context.Provider

`<MyContext.Provider value={/* 某个值 */}>`

每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化

Provider 接收一个 value 属性，传递给消费组件

当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染，无论组件嵌套结构有多么复杂

#### Class.contextType

该 API 仅适用于类式组件，为 class 声明一个指向 Context 实例对象的 contextType 属性，会开启`this.context`对象，允许使用 Context 中的 value，这些值可以在全生命周期中随时调用

```jsx
class App extends Component {
  static contextType = MyContext;

  render() {
    const context = this.context;

    return (
      // ...
    )
  }
}
```

#### Context.Consumer

```jsx
<MyContext.Consumer>
  {value => /* 基于 context 值进行渲染*/}
</MyContext.Consumer>
```

在 Consumer 内部，后代组件可以订阅到 Context 变更

**注意：**消费组件必须是`<MyContext.Provider></MyContext.Provider>`中嵌套组件的后代组件，否则 value 参数为一开始`createContext(defaultValue)`中的 defaultValue

#### Context.displayName

context 对象接受一个名为 displayName 的 property，类型为 string

React DevTools 检测工具中可以以此更名

### 写法

```jsx
import { Component, createContext } from "react";

const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee",
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222",
  },
};

const ThemeContext = createContext({
  theme: themes.light,
  changeTheme: () => {},
});

class ClassContextApp extends Component {
  state = {
    themeSwitch: "dark",
  };

  changeTheme = () => {
    const theme = this.state.themeSwitch;
    this.setState({ themeSwitch: theme === "light" ? "dark" : "light" });
  };

  render() {
    return (
      <ThemeContext.Provider
        value={{
          theme: themes[this.state.themeSwitch],
          changeTheme: this.changeTheme,
        }}
      >
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

function Toolbar(props) {
  return (
    <>
      <ThemedButton />
    </>
  );
}

class ThemedButton extends Component {
  // 声明静态属性后，class中即可使用this.context获取上下文对象
  static contextType = ThemeContext;

  render() {
    const { theme, changeTheme } = this.context;
    return (
      <button
        style={{ background: theme.background, color: theme.foreground }}
        onClick={changeTheme}
      >
        I am styled by theme context!@
      </button>
    );
  }
}

export default ClassContextApp;
```

## Fragments

Fragments 可以减少 render 渲染的节点嵌套，最外部元素在渲染时不会向 DOM 中添加父节点

```js
// 渲染DOM时，只有ChildA ChildB ChildC的DOM元素
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  );
}
```

### 短语法

最简洁的写法，类似空标签

```jsx
class Columns extends React.Component {
  render() {
    return (
      <>
        <td>Hello</td>
        <td>World</td>
      </>
    );
  }
}
```

### 带 key 的情况

使用显式 <React.Fragment> 语法声明的片段可能具有 key。一个使用场景是将一个集合映射到一个 Fragments 数组 - 举个例子，创建一个描述列表：

```jsx
function Glossary(props) {
  return (
    <dl>
      {props.items.map((item) => (
        // 没有`key`，React 会发出一个关键警告
        <React.Fragment key={item.id}>
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </React.Fragment>
      ))}
    </dl>
  );
}
```

## Portals

Portal：门，门户。此处可理解为传送门

该 API 可以将子节点渲染到父组件之外的 DOM 节点上，甚至可以添加到`<body></body>`上

### 语法

`ReactDOM.createPortal(child, container)`

- 第一个参数 child：任意可渲染的子元素
- 第二个参数 container：DOM 元素

```jsx
render() {
  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。
  // `domNode` 是一个可以在任何位置的有效 DOM 节点。
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
```

### 事件冒泡

虽然 portal 可以传送子元素到 DOM 树的任意地方，但是 React 树的挂载顺序是固定的，与 DOM 树中的位置无关，所以 React 的特性仍然不变

这其中就包含事件冒泡，一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树 中的祖先

## `Render-props`

