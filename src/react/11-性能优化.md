---
title: 性能优化
order: 11
category: false
tag:
  - 进阶技巧
  - 性能优化
---

基于 Webpack 等构建工具打包带来的性能优化本章略过，主要讨论 React 内部的针对性优化

## 虚拟滚动

### 参考库

虚拟滚动参考[react-window](https://github.com/bvaughn/react-window)和[react-virtualized](https://github.com/bvaughn/react-virtualized)两个热门库

### 原理

待详解：https://blog.csdn.net/terrychinaz/article/details/112552673

## rerender 优化

![组件rerender](https://misaka10032.oss-cn-chengdu.aliyuncs.com/React/should-component-update.png)

在这张组件树图例中，C6 触发的更新引起组件树重新渲染(rerender)，如果避开无需重渲染的组件：C2 及其子组件、C3 的子组件 C7、C8，最终执行最小量的重渲染组件就只会有 C1-C3-C6，从而提高渲染效率优化加载性能

### 应用

假设场景：组件只有当`props.color`或`state.count`的值改变才需要更新，可以使用 shouldComponentUpdate 来检查

```jsx
class CounterButton extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 1 };
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (this.props.color !== nextProps.color) {
      return true;
    }
    if (this.state.count !== nextState.count) {
      return true;
    }
    return false;
  }

  render() {
    return (
      <button
        color={this.props.color}
        onClick={() => this.setState((state) => ({ count: state.count + 1 }))}
      >
        Count: {this.state.count}
      </button>
    );
  }
}
```

如果 color 和 count 的值没有改变，则组件不会触发 rerender

### `PureComponent`

仅对 props 和 state 中的所有字段作浅比较的情况，使用`React.PureComponent即可`

```jsx
class CounterButton extends React.PureComponent {
  constructor(props) {
    super(props);
    this.state = { count: 1 };
  }

  render() {
    return (
      <button
        color={this.props.color}
        onClick={() => this.setState((state) => ({ count: state.count + 1 }))}
      >
        Count: {this.state.count}
      </button>
    );
  }
}
```

### memo

memo 是 React 面向函数式组件提供的浅比较 API，作用与`PureComponent`相同

```jsx
export default memo(function CounterButton(props) {
  const [count, setCount] = useState(1);

  return (
    <button color={props.color} onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
});
```

### 不可变数据操作

众所周知，React 遵守组件状态不可变的理念，通常在修改 state 的时候都需要使用 ES6 的解构，或者新对象赋值

immer.js 为我们提供了全新的无须使用解构即可触发 React 更新的写法

传统写法：

```jsx
const App = () => {
  const [state, setState] = useState({
    name: "lin",
    todoList: {
      list: [{ name: "吃饭", done: true }],
    },
  });

  const addTodoList = () => {
    setState((state) => ({
      name: state.name,
      todoList: {
        list: [...state.todoList.list, { name: "睡觉", done: true }],
      },
    }));
  };
};
```

使用`immer`：

```jsx
import { produce } from "immer";

const App = () => {
  const [state, setState] = useState({
    name: "lin",
    todoList: {
      list: [{ name: "吃饭", done: true }],
    },
  });

  const addTodoList = () => {
    setState(
      produce((state) => {
        state.todoList.list.push({ name: "睡觉", done: true });
      })
    );
  };
};
```

原理：http://lixianglong.cn/2022/02/25/application/fore-end/nodejs/immer.js%20%E5%85%A5%E9%97%A8/
