---
title: 深入响应式原理
order: 9
category: false
tag:
  - 响应式原理
  - 监视-订阅模式
  - 依赖收集
---

这里是官网的[响应式原理](https://v2.cn.vuejs.org/v2/guide/reactivity.html)原文

当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。

每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

![Vue2响应式原理官网图例](https://misaka10032.oss-cn-chengdu.aliyuncs.com/Vue/data.png)

为了彻底弄懂 Vue2 的数据更新原理，手写相关实现代码，让相关知识不再处于“忽悠阶段”，现记录本章节

## 前言

### MVVM 模式

`<template>` 提供 html 模板视图(view)

`<script>` 中的 data 提供已声明的响应式数据(model)

`<script>` 中的其他对 data 的操作实现 model 和 view 之间的双向响应(view-model)

### 非侵入式变化

Vue 的数据变化语法为 `this.a ++;`，并未调用其他任何 API，为非侵入式数据变化

React 的数据变化语法为 `this.setState({ a: this.state.a ++; })`，小程序同样也是 `this.setData({ a: this.data.a + 1 })`，都需要借助框架的 API 才能修改数据，为侵入式数据变化

### 上帝的钥匙

`Object.defineProperty()` 数据劫持/数据代理

利用 JS 引擎赋予的功能，监测对象属性变化。

但是仅有“上帝的钥匙”不够，还需要设计一套精密的系统，因此需要一套依赖收集与订阅发布系统。

## 1.实现响应式数据劫持函数

### 方法简介

`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

```js
const obj = {};

Object.defineProperty(obj, "a", {
  value: 3,
});

Object.defineProperty(obj, "b", {
  value: 5,
});

console.log(obj); // { a: 3, b: 5 }
console.log(obj.a, obj.b); // 3, 5
```

### 隐藏属性

同时，还可以设置一些额外隐藏的属性，这里只列 2 个为例

```js
Object.defineProperty(obj, "a", {
  value: 3,
  // 是否可写
  writable: false, // 不可写的属性，对obj.a的数据修改不会生效
});

Object.defineProperty(obj, "b", {
  value: 5,
  // 是否可以被枚举
  enumerable: false, // 无法被枚举的属性，对obj作for..in循环的时候不会被读取
});
```

### getter/setter

get：属性的 getter 参数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 `this` 对象（由于继承关系，这里的 `this` 不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。**默认为 undefined**

set：属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（被赋予的新值），会传入赋值时的 `this` 对象。**默认为 undefined**

get 和 set，可以通过闭包存储 get 和 set 的值

```js
Object.defineProperty(obj, "a", {
  // getter
  get() {
    console.log("你试图访问obj的a属性");
  },
  // setter
  set() {
    console.log("你试图改变obj的a属性");
  },
});
console.log(obj.a); // 你试图访问obj的a属性 undefined
obj.a = 10; // 你试图改变obj的a属性 obj.a仍然是undefined
```

**get/set 需要变量周转才能工作**

```js
let temp;

Object.defineProperty(obj, "a", {
  // getter
  get() {
    console.log("你试图访问obj的a属性");
    return temp;
  },
  // setter
  set(newValue) {
    console.log("你试图改变obj的a属性", newValue);
    temp = newValue;
  },
});

console.log(obj.a);
obj.a = 9;
console.log(obj.a); // 9
```

**设置 defineReactive 函数实现变量闭包**

```js
function defineReactive(data, key, val) {
  Object.defineProperty(data, key, {
    // 可枚举
    enumerable: true,
    // 可以被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      console.log(`你试图访问obj的${key}属性`);
      return val;
    },
    // setter
    set(newValue) {
      console.log(`你试图改变obj的${key}属性`, newValue);
      if (val === newValue) {
        return;
      }
      val = newValue;
    },
  });
}

const obj = {};
defineReactive(obj, "a", 10);

console.log(obj.a); // 10
obj.a = 6;
console.log(obj.a); // 6
```

至此，响应式原理的第一步已经完成，**设计实现一个响应式数据劫持函数**