---
title: 计算与监听源码解析
order: 12
category: false
tag:
  - 响应式原理
  - 惰性Computed
  - 深度Watch
---

在[深入响应式原理](./11-深入响应式原理.html)中，我们已经了解了 Observer、Dep、Watcher 之间的关系，最后实现了数据的响应式变化与监听回调，也就是实现了 API 中 data 的响应式数据效果，而且从 Watcher 的源码不难看出，Watcher 类的定义很接近于 API 中 watch 的效果，因此本章对 computed 以及 watch 的源码进行解析，进一步加深对三大依赖收集器（data、computed、watch）中 computed 和 watch 的理解。

## computed 原理与实现

首先，根据[computed 惰性取值](https://v2.cn.vuejs.org/v2/api/#computed)的原理，我们先构建一个配置项，设置惰性的布尔值为 true

`const computedWatcherOptions = { lazy: true }`

### initComputed.js

接下来，初始化 computed 中的配置项

```js
// 初始化computed
import defineComputed from "./defineComputed.js";
import Watcher from "../reactive/watcher.js";

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop(a, b, c) {}

const computedWatcherOptions = { lazy: true };

// vm为组件实例，computed为组件中的 computed 配置项
function initComputed(vm: Component, computed: Object) {
  // 初始化一个 _computedWatchers 属性绑定在组件实例上，用来存储每个计算属性的 watcher 实例
  const watchers = (vm._computedWatchers = Object.create(null));
  // 是否服务端渲染，在当前场景中，isSSR默认永久为false
  const isSSR = isServerRendering();
  //遍历 computed 配置项
  for (const key in computed) {
    const userDef = computed[key];
    // 如果是函数，则该函数默认是getter；不是函数说明是一个对象，则获取对象上面的get函数
    const getter = typeof userDef === "function" ? userDef : userDef.get;
    // 非服务端渲染，当前场景必定为true
    if (!isSSR) {
      // 为计算属性创建内部watcher，保存到 watchers 中
      // computed实际上就是通过 watcher 实现的，第四个参数是关键 { lazy: true }
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }
    // key不能直接绑定在vm实例上，需要通过响应式数据声明
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    }
  }
}
```

### watcher.js

在初始化最后，vm.\_computedWatchers 需要根据 computed 对象中的 key-value 实例化 Watcher，vm 也需要根据不同的 key-value 声明响应式数据，因此需要创建一个`defineComputed`函数，并优化重构[响应式原理](./11-深入响应式原理.html#watcher.js)中的 Watcher 类

- Watcher 类中对 computed 重要的属性在于 dirty（脏值），只有 watcher 实例初始化或调用 update 更新依赖值的时候，dirty 为 true
- watcher 实例调用 evaluate 方法，即封装后的 get 方法，调用一次响应式 get，随后 dirty 为 false
- `defineComputed` 函数实现目标是为组件实例绑定 set 函数和封装后的 get 函数，当且仅当组件实例上绑定的 watcher 实例的 dirty 为 true 时才调用 get 方法，否则直接返回 watcher.value，跳过 get 方法执行

```js
// watcher.js
var id = 0;
export default class Watcher {
  constructor(vm, expOrFn, cb, options) {
    this.vm = vm; // 当前vue实例
    this.expOrFn = expOrFn; //传入的 computed getter方法
    this.cb = cb; // computed 的 cb 为空函数
    if (options) {
      this.lazy = !!options.lazy; // this.lazy=true 默认不执行 这是一个 computed
    }
    this.dirty = this.lazy; // computed 看是否需要从新求值
    this.deps = [];
    this.set = {};
    this.id = id++;
    if (typeof expOrFn === "function") {
      this.getters = expOrFn;
    }
    //留住value
    this.value = this.lazy ? undefined : this.get();
  }
  get() {
    //标记 computed target Dep.target入栈方法
    pushTarget(this);
    // 调用 computed 函数得到计算的值
    let value = this.getters.call(this.vm, this.vm);
    //弹出 target 防止data上每个属性都产生依赖，只有页面上使用的变量需要依赖 Dep.target出栈方法
    popTarget();
    return value;
  }
  run() {
    let newValue = this.get();
  }
  addDep(dep) {
    let id = dep.id;
    //去重防止dep添加watch多次
    if (!this.set[id]) {
      //watcher添加dep
      this.deps.push(dep);
      //给dep添加watch
      dep.addSub(this);
      this.set[id] = true;
    }
  }
  upDate() {
    // 修改属性计算属性依赖的变量重置 dirty，说明value已被修改，外部判断dirty为true会调用evaluate执行一次get()，最后将dirty置为false
    if (this.lazy) {
      this.dirty = true;
    }
  }
  evaluate() {
    //当走到这里时，页面正在渲染中 Dep.target, 已经有一个渲染 watcher 了
    this.value = this.get();
    // 修改了计算属性里面脏值，直到下次value改变之前，evaluate不会再次调用
    this.dirty = false;
  }
  depend() {
    //给 computed 函数内部的属性添加渲染 watcher
    let i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  }
}
```

### defineComputed.js

```js
// defineComputed
function noop(a, b, c) {}

const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop,
};

export default function defineComputed(
  target: any,
  key: string,
  userDef: Object | Function
) {
  // 非服务端环境才有缓存效果，当前场景必定为true
  const shouldCache = !isServerRendering();
  // 传入的是方法，computed传统写法
  if (typeof userDef === "function") {
    // 此处默认为true，调用 createComputedGetter 方法，createGetterInvoker 仅作了解
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    // 传入方法，set为空函数
    sharedPropertyDefinition.set = noop;
  } else {
    // 传入的是get()和set()
    // 不是服务端渲染，调用createComputedGetter
    // 注意，如果computed中某个key不需要缓存，可将cache设置为false
    // 在当前场景中，userDef中仅传入get()和set()，shouldCache 为 true，cache 为 undefined，因此调用 createComputedGetter 方法创建getter
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get)
    // 传入set方法绑定
    sharedPropertyDefinition.set = userDef.set || noop
  }
  // 代理到vm实例上
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

// 创建computed的getter方法
function createComputedGetter (key) {
	// 模板上访问计算属性
  return function computedGetter () {
  	// 取出创建的 computedWatchers，此处为与key值匹配的watcher实例，在 initComputed 时创建
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        // 如果依赖的数据发生了变化，通过调用watcher的update函数，吧dirty的值变为true，需要重新计算值
        watcher.evaluate()
      }
      // computed依赖收集核心：此时渲染还未结束,computed 函数内部的变量收集渲染 watcher
      if (Dep.target) {
        watcher.depend()
      }
      //计算好的参数返回给用户
      return watcher.value
    }
  }
}
```

## watch 原理与实现

在初始化 initState 方法中，如果用户传入的配置有 watch，调用 initWatch 方法。

### initWatch.js

```js
function initWatch(vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key];
    // 监听的是数组
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        // 为数组中每个元素创建watcher
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}
```

### createWatcher.js

- 接下来监听器创建函数，该函数主要针对 handler 的类型做判断（handler 可以是函数类型，也可以是对象类型，也就是 watch 的简写和完整写法），最后返回实例原型的`$watch`方法调用
- `$watch` 中创建独属于 watch 的 user-watch 标识符，new 了一个 watcher 实例对象，关键参数有二，options.user 和 options.immediate
  - options.user，该参数传入 watcher 中实例化时，在 watcher 实例执行依赖更新时，判断出是属于 watch 的监听器，才会执行 cb 回调函数
  - options.immediate，该参数会在 watcher 实例化之后进行一次判断，如果为 true，则自行执行一次 watcher 的回调函数（函数带错误捕获以防止错误的回调执行）

```js
// createWatcher.js

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj: any): boolean {
  return _toString.call(obj) === "[object Object]";
}

function createWatcher(
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  // 如果是对象（配置项形式），handler取对象中的handler函数
  if (isPlainObject(handler)) {
    options = handler;
    // 如果是: test:{handler(old,new){}}
    handler = handler.handler;
  }
  // 监听a.b.c（很少使用）
  if (typeof handler === "string") {
    handler = vm[handler];
  }
  // 返回实例的原型方法 $watch 的返回值，handler对应cb回调函数，options在handler为对象时取出并赋值(deep immediate sync等)
  return vm.$watch(expOrFn, handler, options);
}

// 原型方法$watch
Vue.prototype.$watch = function (
  expOrFn: string | Function,
  cb: any,
  options?: Object
): Function {
  const vm: Component = this;
  // 回调如果是对象，调用createWatcher解构
  if (isPlainObject(cb)) {
    return createWatcher(vm, expOrFn, cb, options);
  }
  options = options || {};
  // 标识这个是用户 user-watch
  options.user = true;
  // 同样，创建内部watcher
  const watcher = new Watcher(vm, expOrFn, cb, options);
  // **立即监听**
  if (options.immediate) {
    const info = `callback for immediate watcher "${watcher.expression}"`;
    pushTarget();
    // 自执行错误捕获函数
    invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
    popTarget();
  }
  return function unwatchFn() {
    watcher.teardown();
  };
};
```

### watcher.js

- Watcher 类有一处特别需要注意的地方，就是 Vue2 的 watch API 中 watch 配置项，其中的 deep 属性将允许开启深度监听，每当调用 get 函数时都需要判断`this.deep`
- `this.deep`为 true 时，需要对 value 值递归式查找其内部嵌套的全部 `__ob__` 属性，以触发 get 进行依赖收集

```js
// watcher.js
import traverse from './deep.js'
var id = 0;

// 属性路径解析，通过'a.b.m.n'的字符串解析出对象内部的属性值
function parsePath(path) {
  path = path.split('.')
	return function (obj) {
		path.forEach((key) => {
		  obj = obj[key]
		})
		return obj
	}
}

export default class Watcher {
    // 四个参数分别是组件实例、属性路径、回调函数、配置项信息
    constructor(vm, expOrFn , cb,options) {
        this.vm = vm
        this.expOrFn = expOrFn //监听的属性 如：a.b.c
        this.cb = cb // watch 回调
        if (options) {
            this.user = !!options.user //这是个 watch
            this.deep = !!options.deep //深度监听
        }
        this.deps = [];
        this.set = {}
        this.id = id++

        if (typeof expOrFn === 'function') {
            // 如果expOrFn是函数，说明是watch的函数简写，直接将函数绑定给getters
            this.getters = expOrFn
        } else {
        	  //访问监听的变量 如：a.b.c.d，解析后返回value值获取函数
            this.getters = parsePath(this.expOrFn)
        }
        //留住 value 调用一次get
        this.value = this.get();
    }
    get() {
        //标记target，Dep.target入栈
        pushTarget(this)
        //访问监听的属性
        let value = this.getters.call(this.vm, this.vm);
        // deep开启深度监听，与其他普通watcher最特别的地方
        if (this.deep) {
            traverse(value)
        }
        //弹出target防止data上每个属性都产生依赖，只有页面上使用的变量需要依赖，Dep.target出栈
        popTarget()
        return value
    }
    run() {
        let newValue = this.get()
        //取出旧值
        const oldValue = this.value
        //留住新值
        this.value = newValue
        //用户自己传入的watch，user-watcher标识符，只有watch的配置项才会声明this.user=true
        if (this.user) {
        	//这里的 cb 就是传入的 watch 回调函数
             this.cb.call(this.vm, newValue, oldValue)
        }
    }
    addDep(dep) {
        let id = dep.id
        //去重防止dep添加watch多次
        if (!this.set[id]) {
            //watcher添加dep
            this.deps.push(dep)
            //给dep添加watch
            dep.addSub(this)
            this.set[id] = true;
        }
    }
    upDate() {
        this.run()
    }
    // 从所有依赖项的订阅者列表中删除自身
    teardown() {
  		if (this.active) {
			// vm实例的watch列表中移除，这是一个开销较大的操作，所以如果vm实例正在被销毁，就跳过
		    if (!this.vm._isBeingDestroyed) {
		      remove(this.vm._watchers, this)
		    }
		    let i = this.deps.length
		    while (i--) {
		      this.deps[i].removeSub(this)
		    }
		    this.active = false
	  }
}
```

### deep.js

- watch 配置项中存在 deep 属性，当 deep 为 true 时可以开启深度监听，上面的 Watcher 类中在 deep 为 true 时调用 traverse 函数

- 实际上 deep 的实现原理就是递归的触发数组或对象的 get 进行依赖收集，又因为 `__ob__` 属性仅有数组和对象才有（详见[递归侦测对象属性](./11-深入响应式原理.html#递归侦测对象属性)），因此在这里需要声明一个递归式手动依赖管理函数，将它们的依赖收集到 Observer 类的 dep 中完成 deep 深度监听

```js
// deep.js
const seenObjects = new Set(); // 不重复添加

export default function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val, seen) {
  let i, keys;
  const isA = Array.isArray(val); // val是否是数组
  const isO = typeof val === "object"; // val是否是对象
  const isF = Object.isFrozen(val); // val是否是冻结对象

  // 如果不是array和object，或者是已经冻结对象（源码上还判断了VNode对象，此处暂时忽略不计）
  if ((!isA && !isO) || isF) {
    return; // 再见
  }

  if (val.__ob__) {
    // 只有object和array才有__ob__属性
    const depId = val.__ob__.dep.uid; // 手动依赖收集器的id
    if (seen.has(depId)) {
      // 已经有收集过
      return; // 再见
    }
    seen.add(depId); // 没有被收集，添加
  }

  if (isA) {
    // 是array
    i = val.length;
    while (i--) {
      _traverse(val[i], seen); // 递归触发每一项的get进行依赖收集
    }
  } else {
    // 是object
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen); // 递归触发子属性的get进行依赖收集
    }
  }
}
```

## 太长不看-总结

在[深入响应式原理](./11-深入响应式原理.html)中，我们了解了响应式原理的三大核心类：Observer、Dep、Watcher。在外部没有新建 watcher 实例时，Observer 实际上已经能对初始的 data 对象实现响应式数据劫持，Vue2 对于 data 中的响应式对象生成的监听实例称之为 render-watcher，是三种 watcher 之一。

### computed

computed 是三种 watcher 之一的 computed-watcher，结合 computed 的配置项来理解：

1. computed 在 vue 实例初始化时，调用一个`initComputed`初始化 computed 的函数，遍历 computed 中的属性，遍历过程中会执行以下步骤
   1. 对其 value 进行类型判断，有两种情况：普通 getter 函数类型或者 getter 与 setter 函数混合的对象类型
   2. 在`initComputed`做类型兼容性判断，并且在当前组件上新建一个 `_computedWatchers` 对象，开启 computed 属性的监听器
   3. 初始化 watcher 时，会传入 getter 方法，与一个`{ lazy: true }`的值，表示这个 watcher 是惰性取值的
   4. 遍历的最后，为当前 computed 属性创建真正的 computed 对象，调用`defineComputed`函数，传入（当前组件实例、computed 属性名、computed 属性值）
2. 在`defineComputed`函数中，computed 属性值中的 getter 函数会进行一次函数柯里化，返回一个经过封装的高阶 getter 方法
   1. 该高阶 getter 函数中，从 `this` 中取出之前已创建好的 `this._computedWatchers[key]` 对象，其实就是对应的 watcher 实例
   2. 每次 getter 的调用，会先判断 watcher 实例的值是否更新（此处记为 dirty，true 表示已更新且未调用 getter，false 表示调用过 getter 无需更新）
   3. 如果 watcher 实例更新，则调用 watcher 的 getter 方法获取依赖值，并执行依赖收集，将当前 computed 相关的所有 watcher 实例收集进来，然后`this.value = 依赖值`，最后 dirty 置为 false
   4. 如果 watcher 实例无需更新，则直接返回 watcher.value，即依赖对象原有的 getter 的值。因为 watcher 实例只要不去更新，`this.value`就稳定不变，因此 computed 在依赖值不更新时，默认直接返回实例的 value 值，而不是去调用 getter 方法获取，此为惰性取值
3. `defineComputed`函数最后，将高阶 getter 方法、可能存在的 setter 方法，一并通过 `Object.defineProperty` 声明在当前组件实例的 computed 属性名上（`vm[key]`）
4. computed 依然是通过 Dep 和 Watcher 收集和更新依赖，不过与普通的 render-watcher 不同之处在于，getter 内部存在 watcher 实例更新判断，如果无需更新则直接返回实例的 value 值，不再调用 watcher 本身的 getter 获取依赖值，实现了数据缓存

### watch

watch 是三种 watcher 之一的 user-watcher，结合 watch 的配置项来理解：

1. watch 在 vue 实例初始化时，调用一个`initWatch`初始化 watch 的函数，遍历 watch 中的属性，遍历过程中会执行以下步骤
   1. 循环遍历创建 user-watcher 实例，调用`createWatcher`函数，传入（当前组件 vm 实例、watch 属性名、watch 属性值）
   2. 在`createWatcher`函数内对 watch 属性值 handler 进行类型判断，有两种情况：普通 handler 函数或者包含 immediate、deep、handler 函数在内的对象（此处不涉及异步处理，暂不写 sync 属性）
   3. 最后调用组件 vm 的原型方法`$watch`方法，传入（watch 属性名、watch 属性值 handler、handler 中的其他配置选项）
2. 在 Vue 的原型方法`$watch`，是实现 user-watcher 的关键方法，初始化 Watcher 实例并传入 user 标识符表示该 watcher 实例属于 user-watcher
   - 最后判断配置选项中的 immediate 是否为 true，如果是，则自动执行一次 watcher 入栈 -> 自执行函数调用与错误捕获函数（防止 handler 函数中出现异常） -> watcher 出栈操作，以实现 handler 函数的立即执行效果
3. 在 Watcher 类中，新增两项配置，deep 和 user，user 为 true 表示是 watch 创建的 user-watcher 实例
   - 当 watcher 实例受 dep 通知，更新依赖值时，只有`this.user`为 true 才会执行 handler 的回调函数
   - 每次 watcher 实例调用 getter 时，都会对`this.deep`进行判断，如果为 true 则表示开启深度监听
   - 开启深度监听后，watcher 实例会对当前的 value 值进行地毯式循环+递归查询，逐项触发 getter 执行 dep 的依赖收集，添加当前 watcher 实例。所以当复杂对象内部属性变化时，开启深度监听亦可触发 watch 的 handler 回调
