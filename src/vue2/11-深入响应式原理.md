---
title: 深入响应式原理
order: 11
category: false
tag:
  - 响应式原理
  - 监视-订阅模式
  - 依赖收集
---

这里是官网的[响应式原理](https://v2.cn.vuejs.org/v2/guide/reactivity.html)原文

当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。

每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

![Vue2响应式原理官网图例](https://misaka10032.oss-cn-chengdu.aliyuncs.com/Vue/data.png)

为了彻底弄懂 Vue2 的数据更新原理，手写相关实现代码，让相关知识不再处于“忽悠阶段”，现记录本章节

## 前言

### MVVM 模式

`<template>` 提供 html 模板视图(view)

`<script>` 中的 data 提供已声明的响应式数据(model)

`<script>` 中的其他对 data 的操作实现 model 和 view 之间的双向响应(view-model)

### 非侵入式变化

Vue 的数据变化语法为 `this.a ++;`，并未调用其他任何 API，为非侵入式数据变化

React 的数据变化语法为 `this.setState({ a: this.state.a ++; })`，小程序同样也是 `this.setData({ a: this.data.a + 1 })`，都需要借助框架的 API 才能修改数据，为侵入式数据变化

### 上帝的钥匙

`Object.defineProperty()` 数据劫持/数据代理

利用 JS 引擎赋予的功能，监测对象属性变化。

但是仅有“上帝的钥匙”不够，还需要设计一套精密的系统，因此需要一套依赖收集与订阅发布系统。

## 1.实现完整的数据劫持

简而言之，对需要数据劫持的对象初始化 Observer 观察者类，并开启数据劫持

### 方法简介

`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

```js
const obj = {};

Object.defineProperty(obj, "a", {
  value: 3,
});

Object.defineProperty(obj, "b", {
  value: 5,
});

console.log(obj); // { a: 3, b: 5 }
console.log(obj.a, obj.b); // 3, 5
```

### 隐藏属性

同时，还可以设置一些额外隐藏的属性，这里只列 2 个为例

```js
Object.defineProperty(obj, "a", {
  value: 3,
  // 是否可写
  writable: false, // 不可写的属性，对obj.a的数据修改不会生效
});

Object.defineProperty(obj, "b", {
  value: 5,
  // 是否可以被枚举
  enumerable: false, // 无法被枚举的属性，对obj作for..in循环的时候不会被读取
});
```

### getter/setter

get：属性的 getter 参数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 `this` 对象（由于继承关系，这里的 `this` 不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。**默认为 undefined**

set：属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（被赋予的新值），会传入赋值时的 `this` 对象。**默认为 undefined**

get 和 set，可以通过闭包存储 get 和 set 的值

```js
Object.defineProperty(obj, "a", {
  // getter
  get() {
    console.log("你试图访问obj的a属性");
  },
  // setter
  set() {
    console.log("你试图改变obj的a属性");
  },
});
console.log(obj.a); // 你试图访问obj的a属性 undefined
obj.a = 10; // 你试图改变obj的a属性 obj.a仍然是undefined
```

**get/set 需要变量周转才能工作**

```js
let temp;

Object.defineProperty(obj, "a", {
  // getter
  get() {
    console.log("你试图访问obj的a属性");
    return temp;
  },
  // setter
  set(newValue) {
    console.log("你试图改变obj的a属性", newValue);
    temp = newValue;
  },
});

console.log(obj.a);
obj.a = 9;
console.log(obj.a); // 9
```

**设置 defineReactive 函数实现变量闭包**

```js
function defineReactive(data, key, val) {
  Object.defineProperty(data, key, {
    // 可枚举
    enumerable: true,
    // 可以被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      console.log(`你试图访问obj的${key}属性`);
      return val;
    },
    // setter
    set(newValue) {
      console.log(`你试图改变obj的${key}属性`, newValue);
      if (val === newValue) {
        return;
      }
      val = newValue;
    },
  });
}

const obj = {};
defineReactive(obj, "a", 10);

console.log(obj.a); // 10
obj.a = 6;
console.log(obj.a); // 6
```

### 递归侦测对象属性(实现 Observer 类)

形如`Object.defineProperty(obj, 'a')` 仅当 a 作为基本类型可以正常监测属性，如果 a 是嵌套对象，则 a 内部的属性变化无法正常监测

```js
// defineReactive.js
function defineReactive(data, key, val) {
  val = val || data[key];
  Object.defineProperty(data, key, {
    // 可枚举
    enumerable: true,
    // 可以被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      console.log(`你试图访问obj的${key}属性`);
      return val;
    },
    // setter
    set(newValue) {
      console.log(`你试图改变obj的${key}属性`, newValue);
      if (val === newValue) {
        return;
      }
      val = newValue;
    },
  });
}

const obj = {
  a: {
    m: {
      n: 5,
    },
  },
};
defineReactive(obj, "a");

console.log(obj); // a是响应式对象数据
obj.a.m.n = 10;
console.log(obj.a.m.n); // n不是响应式数据
```

实际上，Observer 观察者模式需要将一个正常的 object 转换为每个层级的属性都是响应式（可以被侦测）的 object

```js
// util.js __ob__属性定义
export const def = function (obj, key, value, enumerable) {
  Object.defineProperty(obj, key, {
    value,
    enumerable,
    writable: true,
    configurable: true,
  });
};
```

```js
// defineReactive.js
// 响应式数据劫持的核心函数
// 作用1：生成val闭包变量，用以劫持数据
// 作用2：对val变量开启observe类型判断与监听，生成递归结构的观察者类
import observe from "./observe.js";

function defineReactive(data, key, val) {
  val = val || data[key];
  // 定义响应式数据前，先执行一次值类型判断，如果为复杂类型，则会new Observer实例同时遍历key值进入defineReactive的递归执行，直到key的value值为基本类型为止
  observe(val);
  Object.defineProperty(data, key, {
    // 可枚举
    enumerable: true,
    // 可以被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      console.log(`你试图访问${key}属性`);
      return val;
    },
    // setter
    set(newValue) {
      console.log(`你试图改变${key}属性`, newValue);
      if (val === newValue) {
        return;
      }
      val = newValue;
      observe(newValue);
    },
  });
}
```

```js
// observer.js 观察者类
// 数据变量的观察者类
// 作用1：为闭包变量创建实例对象，只要递归结构中存在复杂类型就一定会创建新的实例对象
// 作用2：在实例上声明一个响应式变化的 __ob__ 对象，现阶段暂时用不上
// 作用3：遍历实例的全部key值并开启响应式数据劫持
import { def } from "./util.js";
import defineReactive from "./defineReactive.js";

export default class Observer {
  constructor(value) {
    // 给需要开启监听的对象声明绑定一个初始化的Observer类，key值为__ob__，且不可被枚举
    def(value, "__ob__", this, false);
    // 遍历value的key，对每一个属性都开启监听
    this.walk(value);
  }
  // 遍历
  walk(value) {
    for (let key in value) {
      defineReactive(value, key);
    }
  }
}
```

```js
// 值类型监听判断函数，也是对象观察者模式初始化执行或后续值改变时触发的函数
// 作用1：为复杂数据类型，且没有初始化过Observer实例对象的变量，作new Observer操作
// 作用2：作为defineReactive响应式数据劫持函数的递归操作入口函数，实现多层级复杂类型的递归响应式数据劫持
import Observer from "./observer.js";

export default function observe(value) {
  // 基本类型不再往下执行，递归的跳出条件
  if (typeof value !== "object") return;
  var ob;
  if (typeof value.__ob__ !== "undefined") {
    // 当对象的 __ob__ 不为 undefined 时，说明value已经初始化创建过Observer实例了，此时不再执行new Observer，__ob__是响应式的
    ob = value.__ob__;
  } else {
    // 对象不存在 __ob__ 属性时，new Observer实例对象并初始化value值
    ob = new Observer(value);
  }
  return ob;
}
```

### 数组的响应式处理

上述的实现只能处理普通对象形式，对于数组仍无法正确处理

因此，Vue2 底层改写了数组的 7 个方法：push、pop、shift、unshift、splice、sort、reverse

实现方式：以 `Array.prototype` 为原型，创建一个 arrayMethods 对象

![响应式原理修改数组方法](https://misaka10032.oss-cn-chengdu.aliyuncs.com/Vue/1672982883181.jpg)

```js
// array.js
import { def } from "./util.js";

const arrayPrototype = Array.prototype;

export const arrayMethods = Object.create(arrayPrototype);

const methodsNeedChange = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
];

methodsNeedChange.forEach((methodName) => {
  // 备份原来的方法
  const original = arrayPrototype[methodName];
  // 定义新方法
  def(
    arrayMethods,
    methodName,
    function () {
      // 执行数组的老方法，保证原API顺利执行
      const result = original.apply(this, arguments);

      // 从顶层对象开始递归调用声明下的数组，已经完成了实例初始化，执行`def(value, "__ob__", this, false);`后当前数组必定包含 __ob__ 属性
      const ob = this.__ob__;

      // 7种方法里有3种方法 push / unshift / splice 能够插入新项，现在要把插入的新项也变为observe响应式数据
      let inserted = [];

      switch (methodName) {
        case "push":
        case "unshift":
          inserted = arguments; // 指向插入的新项
          break;
        case "splice":
          // splice参数是splice(下标[，数量[，插入的新项]])
          inserted = Array.from(arguments).slice(2); // 指向第三个参数
          break;
      }

      // 判断有没有要插入的新项
      if (inserted) {
        ob.observeArray(inserted);
      }

      return result; // 返回原API的原返回值
    },
    false
  );
});
```

```js
// observer.js 观察者类
// 数据变量的观察者类
// 作用1：为闭包变量创建实例对象，只要递归结构中存在复杂类型就一定会创建新的实例对象
// 作用2：在实例上声明一个响应式变化的 __ob__ 对象，现阶段暂时用不上
// 作用3：遍历实例的全部key值并开启响应式数据劫持
import { def } from "./util.js";
import defineReactive from "./defineReactive.js";
import { arrayMethods } from "./array.js";

export default class Observer {
  constructor(value) {
    // 给需要开启监听的对象声明绑定一个初始化的Observer类，key值为__ob__，且不可被枚举
    def(value, "__ob__", this, false);
    if (Array.isArray(value)) {
      // 1.如果是数组，将这个数组的原型指向重写后的arrayMethods
      // `Object.setPrototypeOf`：将第一个参数的原型对象指向到第二个参数
      Object.setPrototypeOf(value, arrayMethods);
      // 2.让数组实现响应式
      this.observeArray(value);
    } else {
      // 遍历value的key，对每一个属性都开启监听
      this.walk(value);
    }
  }
  // 遍历
  walk(value) {
    for (let key in value) {
      defineReactive(value, key);
    }
  }
  // 数组的特殊遍历
  observeArray(arr) {
    for (let i = 0, l = arr.length; i < l; i++) {
      // 逐项observe
      observe(arr[i]);
    }
  }
}
```

### 完整的数据劫持源码参考

![调用关系](https://misaka10032.oss-cn-chengdu.aliyuncs.com/Vue/1672995344760.jpg)

至此，可遍历、递归并且对对象和数组都生效的完整数据劫持原理已经实现，阶段性源码参考如下：

```js
// util.js __ob__属性定义
export const def = function (obj, key, value, enumerable) {
  Object.defineProperty(obj, key, {
    value,
    enumerable,
    writable: true,
    configurable: true,
  });
};
```

```js
// defineReactive.js
// 响应式数据劫持的核心函数
// 作用1：生成val闭包变量，用以劫持数据
// 作用2：对val变量开启observe类型判断与监听，生成递归结构的观察者类
import observe from "./observe.js";

function defineReactive(data, key, val) {
  val = val || data[key];
  // 定义响应式数据前，先执行一次值类型判断，如果为复杂类型，则会new Observer实例同时遍历key值进入defineReactive的递归执行，直到key的value值为基本类型为止
  observe(val);
  Object.defineProperty(data, key, {
    // 可枚举
    enumerable: true,
    // 可以被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      console.log(`你试图访问${key}属性`);
      return val;
    },
    // setter
    set(newValue) {
      console.log(`你试图改变${key}属性`, newValue);
      if (val === newValue) {
        return;
      }
      val = newValue;
      observe(newValue);
    },
  });
}
```

```js
// array.js
import { def } from "./util.js";

const arrayPrototype = Array.prototype;

export const arrayMethods = Object.create(arrayPrototype);

const methodsNeedChange = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
];

methodsNeedChange.forEach((methodName) => {
  // 备份原来的方法
  const original = arrayPrototype[methodName];
  // 定义新方法
  def(
    arrayMethods,
    methodName,
    function () {
      // 执行数组的老方法，保证原API顺利执行
      const result = original.apply(this, arguments);

      // 从顶层对象开始递归调用声明下的数组，已经完成了实例初始化，执行`def(value, "__ob__", this, false);`后当前数组必定包含 __ob__ 属性
      const ob = this.__ob__;

      // 7种方法里有3种方法 push / unshift / splice 能够插入新项，现在要把插入的新项也变为observe响应式数据
      let inserted = [];

      switch (methodName) {
        case "push":
        case "unshift":
          inserted = arguments; // 指向插入的新项
          break;
        case "splice":
          // splice参数是splice(下标[，数量[，插入的新项]])
          inserted = Array.from(arguments).slice(2); // 指向第三个参数
          break;
      }

      // 判断有没有要插入的新项
      if (inserted) {
        ob.observeArray(inserted);
      }

      return result; // 返回原API的原返回值
    },
    false
  );
});
```

```js
// observer.js 观察者类
// 数据变量的观察者类
// 作用1：为闭包变量创建实例对象，只要递归结构中存在复杂类型就一定会创建新的实例对象
// 作用2：在实例上声明一个响应式变化的 __ob__ 对象，现阶段暂时用不上
// 作用3：遍历实例的全部key值并开启响应式数据劫持
import { def } from "./util.js";
import defineReactive from "./defineReactive.js";
import { arrayMethods } from "./array.js";

export default class Observer {
  constructor(value) {
    // 给需要开启监听的对象声明绑定一个初始化的Observer类，key值为__ob__，且不可被枚举
    def(value, "__ob__", this, false);
    if (Array.isArray(value)) {
      // 1.如果是数组，将这个数组的原型指向重写后的arrayMethods
      // `Object.setPrototypeOf`：将第一个参数的原型对象指向到第二个参数
      Object.setPrototypeOf(value, arrayMethods);
      // 2.让数组实现响应式
      this.observeArray(value);
    } else {
      // 遍历value的key，对每一个属性都开启监听
      this.walk(value);
    }
  }
  // 遍历
  walk(value) {
    for (let key in value) {
      defineReactive(value, key);
    }
  }
  // 数组的特殊遍历
  observeArray(arr) {
    for (let i = 0, l = arr.length; i < l; i++) {
      // 逐项observe
      observe(arr[i]);
    }
  }
}
```

```js
// 值类型监听判断函数，也是对象观察者模式初始化执行或后续值改变时触发的函数
// 作用1：为复杂数据类型，且没有初始化过Observer实例对象的变量，作new Observer操作
// 作用2：作为defineReactive响应式数据劫持函数的递归操作入口函数，实现多层级复杂类型的递归响应式数据劫持
import Observer from "./observer.js";

export default function observe(value) {
  // 基本类型不再往下执行，递归的跳出条件
  if (typeof value !== "object") return;
  var ob;
  if (typeof value.__ob__ !== "undefined") {
    // 当对象的 __ob__ 不为 undefined 时，说明value已经初始化创建过Observer实例了，此时不再执行new Observer，__ob__是响应式的
    ob = value.__ob__;
  } else {
    // 对象不存在 __ob__ 属性时，new Observer实例对象并初始化value值
    ob = new Observer(value);
  }
  return ob;
}
```

```js
// 代码实现
const obj = {
  a: {
    m: {
      n: 5,
    },
  },
  b: 10,
  c: [1, 2, 3, 4],
};

observe(obj);
console.log("obj", obj);
obj.c.splice(2, 2, 5, 6);
```

三个函数相互调用从而形成了递归，与普通的递归有所不同。
有些同学可能会想，只要在 setter 中调用一下渲染函数来重新渲染页面，不就能完成在数据变化时更新页面了吗？确实可以，但是这样做的代价就是：任何一个数据的变化，都会导致这个页面的重新渲染，代价未免太大了吧。我们想做的效果是：数据变化时，只更新与这个数据有关的 DOM 结构，那就涉及到下文的内容了：依赖

## 2.实现订阅-发布模式的依赖收集

- 在 Vue2 中，中等粒度依赖，用到数据的组件都是依赖
- 在 getter 中收集依赖，在 setter 中触发依赖

**核心：Dep 类和 Watcher 类**

- 把依赖收集的代码封装成一个 Dep 类，它专门用来管理依赖，每个 Observer 的实例，成员中都有一个 Dep 的实例
- Watcher 是一个中介，数据发生变化时通过 Watcher 中转，通知组件
- 下图为官方的订阅-发布模式图例

![发布订阅模式](https://misaka10032.oss-cn-chengdu.aliyuncs.com/Vue/1672988976577.jpg)

- 依赖就是 Watcher。只有 Watcher 触发的 getter 才会收集依赖，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。
- Dep 使用订阅-发布模式，当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。
- 代码实现的巧妙之处：Watcher 把自己设置到全局的一个指定位置，然后读取数据，因为读取了数据，所以会触发这个数据的 getter。在 getter 中就能得到当前正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中。

![更详细的发布订阅模式](https://misaka10032.oss-cn-chengdu.aliyuncs.com/Vue/1672989938316.jpg)

### Watcher 类

Watcher 类作为一个独立的订阅系统，当且仅当依赖的数据发生变化时，接收到数据发生变化的消息时，才会触发 update 更新，最后如果回调函数存在再执行回调（对标 watch 配置项中的 handler）

```js
// watcher.js
// 拆分表达式str，如'a.b.c.d'，会解析出嵌套对象属性的最终路径
function parsePath(str) {
  var segments = str.split(".");
  return (obj) => {
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return;
      obj = obj[segments[i]];
    }
    return obj;
  };
}
var uid = 0;
export default class Watcher {
  // target表示需要监听的目标对象
  // expression表示监听路径，在watch配置项中，对标 '$route.path' 'place.province' 等对象的属性路径
  // callback表示回调函数，在watch配置项中，对标handler函数
  constructor(target, expression, callback) {
    this.id = uid++;
    this.target = target;
    // 属性层级拍平方法
    this.getter = parsePath(expression);
    this.callback = callback;
    this.value = this.get();
  }
  update() {
    this.run();
  }
  get() {
    // 进入依赖收集，让全局的Dep.target设置为watcher本身，进入依赖收集阶段
    // Dep.target为Watcher实例对象，dep的depend触发的时候会添加进dep的subs
    Dep.target = this;
    const obj = this.target;
    var value;
    try {
      this.getter(obj);
    } finally {
      // 最后关闭target
      Dep.target = null;
    }
  }
  run() {
    this.getAndInvoke(this.callback);
  }
  getAndInvoke(cb) {
    const value = this.get();

    if (value !== this.value || typeof value === "object") {
      const oldValue = this.value;
      this.value = value;
      cb.call(this.target, value, oldValue);
    }
  }
}
```

### Dep 类

创建完 Watcher 类之后

每个 Observer 类的构造对象都需要初始化一个 Dep 实例对象，作为依赖收集器

- defineReactive 数据劫持函数需要引入 Dep，Dep 面向闭包变量
- Observer 观察者类初始化时也需要实例化 Dep，Dep 面向 `__ob__`
- 数据劫持对象 setter 或数组重写方法触发时，调用 dep 的 notify 方法通知 Watcher 类

```js
// dep.js

var uid = 0;
export default class Dep {
  constructor() {
    this.id = uid++;
    // 存储订阅者数组 subscribes
    // 数组里实际存放的是 Watcher 的实例对象
    this.subs = [];
  }
  // 添加依赖
  depend() {
    // Dep.target 处于依赖收集阶段的判断标志
    if (Dep.target) {
      this.addSub(Dep.target);
    }
  }
  // 添加订阅
  addSub(sub) {
    this.subs.push(sub);
  }
  // 通知更新
  notify() {
    // 浅拷贝
    const subs = this.subs.slice();
    // 遍历
    for (let i = 0, l = subs.length; i < l; i++) {
      // Watcher实例对象的update方法调用，更新响应式数据
      subs[i].update();
    }
  }
}
```

```js
// defineReactive.js
// 响应式数据劫持的核心函数
// 作用1：生成val闭包变量，用以劫持数据
// 作用2：对val变量开启observe类型判断与监听，生成递归结构的观察者类
import observe from "./observe.js";
import Dep from "./dep.js";

function defineReactive(data, key, val) {
  const dep = new Dep();
  val = val || data[key];
  // 定义响应式数据前，先执行一次值类型判断，如果为复杂类型，则会new Observer实例同时遍历key值进入defineReactive的递归执行，直到key的value值为基本类型为止
  let childOb = observe(val);
  Object.defineProperty(data, key, {
    // 可枚举
    enumerable: true,
    // 可以被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      console.log(`你试图访问${key}属性`);
      // 如果处于依赖收集阶段，调用依赖收集方法
      if (Dep.target) {
        dep.depend();
        // 为何需要判断childOb？childOb指向的是当前data[key]中的val内部的子对象的dep
        // childOb存在的情况只有一种，那就是val为复杂类型数据时，此时应该要对该复杂类型内部的dep也做一次依赖收集
        if (childOb) {
          childOb.dep.depend();
        }
      }
      return val;
    },
    // setter
    set(newValue) {
      console.log(`你试图改变${key}属性`, newValue);
      if (val === newValue) {
        return;
      }
      val = newValue;
      childOb = observe(newValue);
      // 触发setter时调用notify
      dep.notify();
    },
  });
}
```

```js
// array.js
import { def } from "./util.js";

const arrayPrototype = Array.prototype;

export const arrayMethods = Object.create(arrayPrototype);

const methodsNeedChange = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
];

methodsNeedChange.forEach((methodName) => {
  // 备份原来的方法
  const original = arrayPrototype[methodName];
  // 定义新方法
  def(
    arrayMethods,
    methodName,
    function () {
      // 执行数组的老方法，保证原API顺利执行
      const result = original.apply(this, arguments);

      // 从顶层对象开始递归调用声明下的数组，已经完成了实例初始化，执行`def(value, "__ob__", this, false);`后当前数组必定包含 __ob__ 属性
      const ob = this.__ob__;

      // 7种方法里有3种方法 push / unshift / splice 能够插入新项，现在要把插入的新项也变为observe响应式数据
      let inserted = [];

      switch (methodName) {
        case "push":
        case "unshift":
          inserted = arguments; // 指向插入的新项
          break;
        case "splice":
          // splice参数是splice(下标[，数量[，插入的新项]])
          inserted = Array.from(arguments).slice(2); // 指向第三个参数
          break;
      }

      // 判断有没有要插入的新项
      if (inserted) {
        ob.observeArray(inserted);
      }

      // 触发7种方法之一时，调用notify
      ob.dep.notify();

      return result; // 返回原API的原返回值
    },
    false
  );
});
```

```js
// observer.js 观察者类
// 数据变量的观察者类
// 作用1：为闭包变量创建实例对象，只要递归结构中存在复杂类型就一定会创建新的实例对象
// 作用2：在实例上声明一个响应式变化的 __ob__ 对象，现阶段暂时用不上
// 作用3：遍历实例的全部key值并开启响应式数据劫持
import { def } from "./util.js";
import defineReactive from "./defineReactive.js";
import { arrayMethods } from "./array.js";

export default class Observer {
  constructor(value) {
    // 给需要开启监听的对象声明绑定一个初始化的Observer类，key值为__ob__，且不可被枚举
    def(value, "__ob__", this, false);
    if (Array.isArray(value)) {
      // 1.如果是数组，将这个数组的原型指向重写后的arrayMethods
      // `Object.setPrototypeOf`：将第一个参数的原型对象指向到第二个参数
      Object.setPrototypeOf(value, arrayMethods);
      // 2.让数组实现响应式
      this.observeArray(value);
    } else {
      // 遍历value的key，对每一个属性都开启监听
      this.walk(value);
    }
  }
  // 遍历
  walk(value) {
    for (let key in value) {
      defineReactive(value, key);
    }
  }
  // 数组的特殊遍历
  observeArray(arr) {
    for (let i = 0, l = arr.length; i < l; i++) {
      // 逐项observe
      observe(arr[i]);
    }
  }
}
```

最后，亟待补充：https://juejin.cn/post/6932659815424458760#heading-1