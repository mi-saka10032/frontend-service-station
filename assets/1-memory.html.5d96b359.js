import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as e,d as r}from"./app.67ca6e1b.js";const l={},p=r('<h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><p>JS 中的内存管理遵循：申请内存空间 -&gt; 使用内存空间 -&gt; 释放内存空间 的顺序</p><p>垃圾回收机制：</p><ol><li>JS 自动进行内存管理</li><li>对象不再被引用时就是垃圾</li><li>对象不能从根（全局变量对象）上访问的时候就是垃圾</li></ol><p>下面的垃圾回收算法都按照这个机制执行垃圾回收</p><h3 id="垃圾回收-gc-算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收-gc-算法" aria-hidden="true">#</a> 垃圾回收(GC)算法</h3><p>GC 可以找到内存中的垃圾，并释放和回收空间</p><p>优点：</p><ul><li>发现垃圾立即回收</li><li>最大限度地减少程序暂停</li></ul><p>缺点：</p><ul><li>循环引用对象无法回收</li><li>时间开销大（时刻维护对象的引用）</li></ul><p>常用的 GC 算法如下。</p><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><p>维护一个引用计数器，判断当前引用数是否为 0</p><p>引用数字为 0 的时候立即回收</p><p>互相引用的对象无法被回收</p><p>优缺点：</p><ul><li>可以即时回收垃圾对象</li><li>减少程序卡顿时间</li><li>无法回收循环引用的对象</li><li>资源消耗较大</li></ul><h3 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h3><p>分标记阶段和清除阶段两个阶段</p><p>遍历所有对象找标记活动对象</p><p>遍历所有对象清除没有标记对象</p><p>回收相应空间</p><p>优缺点：</p><ul><li>相对于引用计数，可以回收循环引用但没有用处的对象</li><li>内存空间地址不连续、空间碎片化，由于回收的对象在本来的地址也是不连续的，就会导致回收的对象地址也是不连续的，浪费空间</li><li>不会立即回收垃圾对象</li></ul><h3 id="标记整理" tabindex="-1"><a class="header-anchor" href="#标记整理" aria-hidden="true">#</a> 标记整理</h3><p>标记清除的增强版</p><p>标记阶段的操作和标记清除一致</p><p><strong>清除阶段会先执行整理，移动对象位置</strong>，重点就是这个整理，标记清除就是因为回收的对象的地址不连续，导致碎片空间化。而标记整理会在清除前，先整理一遍，将活动的对象移动到一起，需要回收的对象移动到一起，这样回收的时候，回收对象的地址就是连续的。</p><p>优缺点：</p><ul><li>减少碎片化空间</li><li>不会立即回收垃圾对象</li></ul><h2 id="v8-垃圾回收策略" tabindex="-1"><a class="header-anchor" href="#v8-垃圾回收策略" aria-hidden="true">#</a> V8 垃圾回收策略</h2><p>V8 引擎采用的是分代回收</p><p>内存分为新生代存储区和老生代存储区，针对不同的对象采用不同的算法</p><p>V8 中常用的 GC：<strong>分代回收、空间复制、标记清除、标记整理、标记增量</strong></p><h3 id="新生代处理" tabindex="-1"><a class="header-anchor" href="#新生代处理" aria-hidden="true">#</a> 新生代处理</h3><p>V8 将内存空间一分为二</p><p>小空间用于存储新生代对象（32M | 16M）</p><p>新生代对象指的是存活时间较短的对象</p><h4 id="新生代对象回收实现" tabindex="-1"><a class="header-anchor" href="#新生代对象回收实现" aria-hidden="true">#</a> 新生代对象回收实现</h4><p>回收过程采用复制算法+标记整理</p><p>新生代内存区分为两个等大小空间</p><p>使用空间为 from，空闲空间为 to</p><p>活动对象存储于 from 空间</p><p>标记整理后将活动对象拷贝至 to 空间</p><p>from 与 to 交换空间完成释放</p><h4 id="回收细节说明" tabindex="-1"><a class="header-anchor" href="#回收细节说明" aria-hidden="true">#</a> 回收细节说明</h4><p>拷贝过程中可能出现晋升</p><p>晋升就是将新生代对象移动至老生代</p><p>一轮 GC 还存活的新生代就需要晋升</p><p>to 空间的使用率超过 25%</p><h3 id="老生代处理" tabindex="-1"><a class="header-anchor" href="#老生代处理" aria-hidden="true">#</a> 老生代处理</h3><p>老生代对象存放在右侧老生代区域</p><p>64 位操作系统 1.4G，32 位操作系统 700M</p><p>老生代对象指的是存活时间较长的对象</p><h4 id="老生代对象回收实现" tabindex="-1"><a class="header-anchor" href="#老生代对象回收实现" aria-hidden="true">#</a> 老生代对象回收实现</h4><p>主要采用标记清除，标记整理，增量标记算法</p><p>首先使用标记清除完成垃圾空间的回收（空间碎片）</p><p>采用标记整理进行空间优化（晋升的时候，使用标记整理，进行空间优化）</p><p>采用增量标记进行效率优化</p><h3 id="新老生代回收细节对比" tabindex="-1"><a class="header-anchor" href="#新老生代回收细节对比" aria-hidden="true">#</a> 新老生代回收细节对比</h3><p>新生代区域垃圾回收使用空间换时间</p><p>老生代其余回收不适合复制算法（数量多、空间大）</p><h3 id="增量标记优化" tabindex="-1"><a class="header-anchor" href="#增量标记优化" aria-hidden="true">#</a> 增量标记优化</h3><p>标记阶段的时候，会阻塞 JS 执行，而增量标记就是将标记的过程，分为几个小标记分段回收，以优化用户体验</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>V8 采用即时编译、内存设限，使用分代回收思想实现垃圾回收</p><p>V8 中的内存分为新生代和老生代</p><p>V8 常见的 GC 算法：</p><ul><li>新生代：复制算法+标记整理</li><li>老生代：标记清除，标记整理，增量标记算法</li></ul><h2 id="js-代码优化" tabindex="-1"><a class="header-anchor" href="#js-代码优化" aria-hidden="true">#</a> JS 代码优化</h2><ul><li>慎用全局变量：全局变量定义在全局执行上下文，是所有作用域的顶端，而且全局上下文会一直存在上下文执行栈，直到程序退出，还会导致局部变量遮蔽污染。</li><li>缓存全局变量，比如缓存 dom 节点，避免频繁获取</li><li>通过原型新增方法</li><li>避免属性访问方法使用，就是对象直接获取属性就行，不用封装方法获取属性。</li><li>for 循环遍历的时候，如果是数组长度，可以提前使用变量保存，不用每次循环都去获取。</li><li>遍历一个数组，forEach 的性能比 for 和 for in 好。优化后的 for(数组长度提前读取)的性能比 for in 好。</li><li><strong>节点添加优化</strong>，使用文档碎片<code>(document.createDocumentFragment)</code>添加节点，等节点添加完毕之后再统一加入到 dom 上。</li><li>克隆节点比创建节点性能更高</li><li>直接量替换 Object 操作，比如数组，<code>const a = [1,2,3]</code>替换 <code>const a = new Array(1,2,3)</code></li><li>减少判断层级，if else 中，退出的情况应该放在最前判断，复杂层级深的情况应该放在最后</li><li>减少作用域链查找层级</li><li>减少数据读取次数，比如 dom 读取，可以先缓存。</li><li>减少声明及语句数</li><li>采用事件委托代替多个事件注册。</li></ul>',72),h=[p];function d(n,t){return i(),e("div",null,h)}const s=a(l,[["render",d],["__file","1-memory.html.vue"]]);export{s as default};
