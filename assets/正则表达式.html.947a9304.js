import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as p,c as o,e as l,w as c,d as n,r,a as s,b as a}from"./app.c7365eef.js";const i={},u=n(`<p>正则表达式是一种通用的工具，在 JavaScript、PHP、Java、Python、C++ 等几乎所有的编程语言中都能使用；但是，不同编程语言对正则表达式语法的支持不尽相同，有的编程语言支持所有的语法，有的仅支持一个子集。本节讲到的正则表达式语法适用于 JavaScript。</p><p>正则表达式的语法体现在字符模式上。字符模式是一组特殊格式的字符串，它由一系列特殊字符和普通字符构成，其中每个特殊字符都包含一定的语义和功能。</p><h2 id="描述功能" tabindex="-1"><a class="header-anchor" href="#描述功能" aria-hidden="true">#</a> 描述功能</h2><p>根据正则表达式语法规则，大部分字符仅能够描述自身，这些字符被称为普通字符，如所有的字母、数字等。</p><p>元字符就是拥有特动功能的特殊字符，大部分需要加反斜杠进行标识，以便于普通字符进行区别，而少数元字符，需要加反斜杠，以便转译为普通字符使用。JavaScript 正则表达式支持的元字符如表所示。</p><table><thead><tr><th style="text-align:left;">元字符</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">.</td><td style="text-align:left;">查找单个字符，除了换行和行结束符</td></tr><tr><td style="text-align:left;">\\w</td><td style="text-align:left;">查找单词字符</td></tr><tr><td style="text-align:left;">\\W</td><td style="text-align:left;">查找非单词字符</td></tr><tr><td style="text-align:left;">\\d</td><td style="text-align:left;">查找数字</td></tr><tr><td style="text-align:left;">\\D</td><td style="text-align:left;">查找非数字字符</td></tr><tr><td style="text-align:left;">\\s</td><td style="text-align:left;">查找空白字符</td></tr><tr><td style="text-align:left;">\\S</td><td style="text-align:left;">查找非空白字符</td></tr><tr><td style="text-align:left;">\\b</td><td style="text-align:left;">匹配单词边界</td></tr><tr><td style="text-align:left;">\\B</td><td style="text-align:left;">匹配非单词边界</td></tr><tr><td style="text-align:left;">\\0</td><td style="text-align:left;">查找 NUL 字符</td></tr><tr><td style="text-align:left;">\\n</td><td style="text-align:left;">查找换行符</td></tr><tr><td style="text-align:left;">\\f</td><td style="text-align:left;">查找换页符</td></tr><tr><td style="text-align:left;">\\r</td><td style="text-align:left;">查找回车符</td></tr><tr><td style="text-align:left;">\\t</td><td style="text-align:left;">查找制表符</td></tr><tr><td style="text-align:left;">\\v</td><td style="text-align:left;">查找垂直制表符</td></tr><tr><td style="text-align:left;">\\xxx</td><td style="text-align:left;">查找以八进制数 xxxx 规定的字符</td></tr><tr><td style="text-align:left;">\\xdd</td><td style="text-align:left;">查找以十六进制数 dd 规定的字符</td></tr><tr><td style="text-align:left;">\\uxxxx</td><td style="text-align:left;">查找以十六进制 xxxx 规定的 Unicode 字符</td></tr></tbody></table><p>表示字符的方法有多种，除了可以直接使用字符本身外，还可以使用 ASCII 编码或者 Unicode 编码来表示。</p><p>示例 1</p><p>下面使用 ASCII 编码定义正则表达式直接量。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\x61</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于字母 a 的 ASCII 编码为 97，被转换为十六进制数值后为 61，因此如果要匹配字符 a，就应该在前面添加“\\x”前缀，以提示它为 ASCII 编码。</p><br><p>示例 2</p><p>除了十六进制外，还可以直接使用八进制数值表示字符。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\141</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用十六进制需要添加“\\x”前缀，主要是为了避免语义混淆，而八进制则不需要添加前缀。</p><br><p>示例 3</p><p>ASCII 编码只能够匹配有限的单字节字符，使用 Unicode 编码可以表示双字节字符。Unicode 编码方式：“\\u”前缀加上 4 位十六进制值。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token string">&quot;/\\u0061/&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 RegExp() 构造函数中使用元字符时，应使用双斜杠。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;\\\\u0061&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>转义字符 \\</p><p>RegExp() 构造函数的参数只接受字符串，而不是字符模式。在字符串中，任何字符加反斜杠还表示字符本身，如字符串“\\u”就被解释为 u 本身，所以对于“\\u0061”字符串来说，在转换为字符模式时，就被解释为“u0061”，而不是“\\u0061”，此时反斜杠就失去转义功能。解决方法：在字符 u 前面加双反斜杠。</p><h2 id="描述字符范围" tabindex="-1"><a class="header-anchor" href="#描述字符范围" aria-hidden="true">#</a> 描述字符范围</h2><p>在正则表达式语法中，放括号表示字符范围。在方括号中可以包含多个字符，表示匹配其中任意一个字符。如果多个字符的编码顺序是连续的，可以仅指定开头和结尾字符，省略中间字符，仅使用连字符~表示。如果在方括号内添加脱字符^前缀，还可以表示范围之外的字符。例如：</p><ul><li><p>[abc]：查找方括号内任意一个字符。</p></li><li><p>[^abc]：查找不在方括号内的字符。</p></li><li><p>[0-9]：查找从 0 至 9 范围内的数字，即查找数字。</p></li><li><p>[a-z]：查找从小写 a 到小写 z 范围内的字符，即查找小写字母。</p></li><li><p>[A-Z]：查找从大写 A 到大写 Z 范围内的字符，即查找大写字母。</p></li><li><p>[A-z]：查找从大写 A 到小写 z 范围内的字符，即所有大小写的字母。</p></li></ul><p>示例 1</p><p>字符范围遵循字符编码的顺序进行匹配。如果将要匹配的字符恰好在字符编码表中特定区域内，就可以使用这种方式表示。</p><p>匹配任意 ASCII 字符：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\u0000-\\u00ff]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>匹配任意双字节的汉字：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[^\\u0000-\\u00ff]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>匹配任意大小写字母和数字：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-zA-Z0-9]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 Unicode 编码设计，匹配数字：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\u0030-\\u0039]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用下面字符模式可以匹配任意大写字母：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\u0041-\\u004A]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用下面字符模式可以匹配任意小写字母：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\\u0061-\\u007A]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><p>示例 2</p><p>在字符范围内可以混用各种字符模式。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;abcdez&quot;</span><span class="token punctuation">;</span> <span class="token comment">//字符串直接量</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[abce-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span> <span class="token comment">//字符a、b、c，以及从e~z之间的任意字符</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;,&quot;z&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><p>示例 3</p><p>在中括号内不要有空格，否则会误解为还要匹配空格。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[0-9]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><p>示例 4</p><p>字符范围可以组合使用，以便设计更灵活的匹配模式。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;abc4 abd6 abe3 abf1 abg7&quot;</span><span class="token punctuation">;</span> <span class="token comment">//字符串直接量</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab[c-g][1-7]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span> <span class="token comment">//前两个字符为ab，第三个字符为从c到g，第四个字符为1~7的任意数字</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;abc4&quot;,&quot;abd6&quot;,&quot;abe3&quot;,&quot;abf1&quot;,&quot;abg7&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><p>示例 5</p><p>使用反义字符范围可以匹配很多无法直接描述的字符，达到以少应多的目的。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[^0123456789]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这个正则表达式中，将会匹配除了数字以外任意的字符。反义字符类比简单字符类的功能更强大和实用。</p><h2 id="选择匹配" tabindex="-1"><a class="header-anchor" href="#选择匹配" aria-hidden="true">#</a> 选择匹配</h2><p>选择匹配类似于 JavaScript 的逻辑与运算，使用竖线|描述，表示在两个表达式分组的匹配结果中任选一个。例如：</p><ol><li>匹配任意数字或字母</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\w+|\\d+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>可以定义多重选择模式。设计方法：在多个表达式分组之间加入选择操作符。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(abc)|(efg)|(123)|(456)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了避免歧义，应该为选择操作的多个表达式分组加上小括号。</p><p>示例</p><p>设计对提交的表单字符串进行关键词过滤。先设计一个关键词列表，然后使用竖线把它们连接在一起，定义选择匹配模式，最后使用字符串的 replace() 方法把所有关键字符替换为可以显示的编码格式。代码如下：</p>`,67),d=s("div",{class:"language-html line-numbers-mode","data-ext":"html"},[s("pre",{class:"language-html"},[s("code",null,[s("span",{class:"token comment"},"<!-- codepen中可查看正常结果 -->"),a(`
`),s("span",{class:"token tag"},[s("span",{class:"token tag"},[s("span",{class:"token punctuation"},"<"),a("p")]),a(),s("span",{class:"token attr-name"},"class"),s("span",{class:"token attr-value"},[s("span",{class:"token punctuation attr-equals"},"="),s("span",{class:"token punctuation"},'"'),a("p1"),s("span",{class:"token punctuation"},'"')]),s("span",{class:"token punctuation"},">")]),s("span",{class:"token tag"},[s("span",{class:"token tag"},[s("span",{class:"token punctuation"},"</"),a("p")]),s("span",{class:"token punctuation"},">")]),a(`
`),s("span",{class:"token tag"},[s("span",{class:"token tag"},[s("span",{class:"token punctuation"},"<"),a("p")]),a(),s("span",{class:"token attr-name"},"class"),s("span",{class:"token attr-value"},[s("span",{class:"token punctuation attr-equals"},"="),s("span",{class:"token punctuation"},'"'),a("p2"),s("span",{class:"token punctuation"},'"')]),s("span",{class:"token punctuation"},">")]),s("span",{class:"token tag"},[s("span",{class:"token tag"},[s("span",{class:"token punctuation"},"</"),a("p")]),s("span",{class:"token punctuation"},">")]),a(`
`),s("span",{class:"token tag"},[s("span",{class:"token tag"},[s("span",{class:"token punctuation"},"<"),a("script")]),s("span",{class:"token punctuation"},">")]),s("span",{class:"token script"},[s("span",{class:"token language-javascript"},[a(`
  `),s("span",{class:"token keyword"},"var"),a(" s "),s("span",{class:"token operator"},"="),a(),s("span",{class:"token string"},`'<meta charset="utf-8">'`),s("span",{class:"token punctuation"},";"),a(),s("span",{class:"token comment"},"//待过滤的表单提交信息"),a(`
  `),s("span",{class:"token keyword"},"var"),a(" r "),s("span",{class:"token operator"},"="),a(),s("span",{class:"token regex"},[s("span",{class:"token regex-delimiter"},"/"),s("span",{class:"token regex-source language-regex"},`\\'|\\"|\\<|\\>`),s("span",{class:"token regex-delimiter"},"/"),s("span",{class:"token regex-flags"},"gi")]),s("span",{class:"token punctuation"},";"),a(),s("span",{class:"token comment"},"//过滤关键字符的正则表达式"),a(`
  `),s("span",{class:"token keyword"},"function"),a(),s("span",{class:"token function"},"f"),s("span",{class:"token punctuation"},"("),s("span",{class:"token punctuation"},")"),a(),s("span",{class:"token punctuation"},"{"),a(`
    `),s("span",{class:"token comment"},"//替换函数"),a(`
    `),s("span",{class:"token comment"},"////把关键字符替换为对应的网页显示的编码格式"),a(`
    `),s("span",{class:"token keyword"},"return"),a(),s("span",{class:"token string"},'"&#"'),a(),s("span",{class:"token operator"},"+"),a(" arguments"),s("span",{class:"token punctuation"},"["),s("span",{class:"token number"},"0"),s("span",{class:"token punctuation"},"]"),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"charCodeAt"),s("span",{class:"token punctuation"},"("),s("span",{class:"token number"},"0"),s("span",{class:"token punctuation"},")"),a(),s("span",{class:"token operator"},"+"),a(),s("span",{class:"token string"},'";"'),s("span",{class:"token punctuation"},";"),a(`
  `),s("span",{class:"token punctuation"},"}"),a(`
  `),s("span",{class:"token keyword"},"var"),a(" a "),s("span",{class:"token operator"},"="),a(" s"),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"replace"),s("span",{class:"token punctuation"},"("),a("r"),s("span",{class:"token punctuation"},","),a(" f"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),a(),s("span",{class:"token comment"},"//执行过滤替换"),a(`
  document`),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"querySelector"),s("span",{class:"token punctuation"},"("),s("span",{class:"token string"},'".p1"'),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},"."),a("innerHTML "),s("span",{class:"token operator"},"="),a(" a"),s("span",{class:"token punctuation"},";"),a(),s("span",{class:"token comment"},"//在p1中显示正常的字符标签信息"),a(`
  document`),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"querySelector"),s("span",{class:"token punctuation"},"("),s("span",{class:"token string"},'".p2"'),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},"."),a("innerText "),s("span",{class:"token operator"},"="),a(" a"),s("span",{class:"token punctuation"},";"),a(),s("span",{class:"token comment"},"//在p2中显示正常的字符信息"),a(`
`)])]),s("span",{class:"token tag"},[s("span",{class:"token tag"},[s("span",{class:"token punctuation"},"</"),a("script")]),s("span",{class:"token punctuation"},">")]),a(`
`)])]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"})])],-1),k=n(`<h2 id="重复匹配" tabindex="-1"><a class="header-anchor" href="#重复匹配" aria-hidden="true">#</a> 重复匹配</h2><p>在正则表达式语法中，定义了一组重复类量词，如表所示。它们定义了重复匹配字符的确数或约数。</p><table><thead><tr><th style="text-align:left;">量词</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>n+</code></td><td style="text-align:left;">匹配任何包含至少一个 n 的字符串</td></tr><tr><td style="text-align:left;"><code>n\\*</code></td><td style="text-align:left;">匹配任何包含零个或多个 n 的字符串</td></tr><tr><td style="text-align:left;"><code>n?</code></td><td style="text-align:left;">匹配任何包含零个或一个 n 的字符串</td></tr><tr><td style="text-align:left;"><code>n{x}</code></td><td style="text-align:left;">匹配包含 x 个 n 的序列的字符串</td></tr><tr><td style="text-align:left;"><code>n{x,y}</code></td><td style="text-align:left;">匹配包含最少 x 个、最多 y 个 n 的序列的字符串</td></tr><tr><td style="text-align:left;"><code>n{x,}</code></td><td style="text-align:left;">匹配包含至少 x 个 n 的序列的字符串</td></tr></tbody></table><p>示例</p><p>下面结合示例进行演示说明，先设计一个字符串：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span>
  <span class="token string">&quot;ggle gogle google gooogle goooogle gooooogle goooooogle gooooooogle goooooooogle&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>如果仅匹配单词 ggle 和 gogle，可以设计：</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go?gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>量词?表示前面字符或表达式分组为可有可无，等效于：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go{0,1}gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>如果匹配第 4 个单词 gooogle，可以设计：</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go{3}gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>等效于：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">gooogle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>如果匹配第 4 个到第 6 个之间的单词，可以设计：</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go{3,5}gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>如果匹配所有单词，可以设计：</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go*gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>量词*表示前面字符或表达式可以不出现，或者重复出现任意多次。等效于：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go(0,)gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>如果匹配包含字符“o”的所有词，可以设计：</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go+gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>量词+表示前面字符或表达式分组至少出现 1 次，最多重复次数不限。等效于：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go{1,}gle</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>重复类量词总是出现在它们所作用的字符或表达式分组后面。如果想作用于多个字符，需要使用小括号把它们包裹在一起形成一个表达式分组。</p><h2 id="惰性匹配" tabindex="-1"><a class="header-anchor" href="#惰性匹配" aria-hidden="true">#</a> 惰性匹配</h2><p>重复类量词都具有贪婪性，在条件允许的前提下，会匹配尽可能多的字符。</p><ul><li><p>?、{n} 和 {n,m} 重复类具有弱贪婪性，表现为贪婪的有限性。</p></li><li><p>*、+ 和 {n,} 重复类具有强贪婪性，表现为贪婪的无限性。</p></li></ul><p>示例 1</p><p>越是排在左侧的重复类量词匹配优先级越高。下面示例显示当多个重复类量词同时满足条件时，会在保证右侧重复类量词最低匹配次数基础上，使最左侧的重复类量词尽可能占有所有字符。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(&lt;.*&gt;)(&lt;.*&gt;)</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//左侧表达式匹配&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>；
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//右侧表达式匹配“&lt;/html&gt;”</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与贪婪匹配相反，惰性匹配将遵循另一种算法：在满足条件的前提下，尽可能少的匹配字符。定义惰性匹配的方法：在重复类量词后面添加问号?限制词。贪婪匹配体现了最大化匹配原则，惰性匹配则体现最小化匹配原则。</p><p>示例 2</p><p>下面示例演示了如何定义匹配模式。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;.*?&gt;</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回单个元素数组[&quot;&lt;html&gt;&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面示例中，对于正则表达式 /&lt;.*?&gt;/ 来说，它可以返回匹配字符串 &quot;&lt;&gt;&quot;，但是为了能够确保匹配条件成立，在执行中还是匹配了带有 4 个字符的字符串“html”。惰性取值不能够以违反模式限定的条件而返回，除非没有找到符合条件的字符串，否则必须满足它。</p><p>针对 6 种重复类惰性匹配的简单描述如下：</p><ul><li><p>{n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。</p></li><li><p>{n}?：尽量匹配 n 次。</p></li><li><p>{n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。</p></li><li><p>??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。</p></li><li><p>+?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。</p></li><li><p>*? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。</p></li></ul><h2 id="边界量词" tabindex="-1"><a class="header-anchor" href="#边界量词" aria-hidden="true">#</a> 边界量词</h2><p>边界就是确定匹配模式的位置，如字符串的头部或尾部，具体说明如表所示。</p><table><thead><tr><th style="text-align:left;">量词</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">^</td><td style="text-align:left;">匹配开头，在多行检测中，会匹配一行的开头</td></tr><tr><td style="text-align:left;">$</td><td style="text-align:left;">匹配结尾，在多行检测中，会匹配一行的结尾</td></tr></tbody></table><p>下面代码演示如何使用边界量词。先定义字符串：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;how are you&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>匹配最后一个单词</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\w+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;you&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>匹配第一个单词</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\w+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;how&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>匹配每一个单词</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\w+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;how&quot;,&quot;are&quot;,&quot;you&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="声明词量" tabindex="-1"><a class="header-anchor" href="#声明词量" aria-hidden="true">#</a> 声明词量</h2><p>声明表示条件的意思。声明词量包括正向声明和反向声明两种模式。</p><h3 id="正向声明" tabindex="-1"><a class="header-anchor" href="#正向声明" aria-hidden="true">#</a> 正向声明</h3><p>指定匹配模式后面的字符必须被匹配，但又不返回这些字符。语法格式如下：</p><p>匹配模式 (?= 匹配条件)</p><p>声明包含在小括号内，它不是分组，因此作为表达式分组。</p><p>下面代码定义一个正前向生命的匹配模式。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;one : 1; two : 2&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\w*(?==)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">//使用正前向声明，指定执行匹配必须满足的条件</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;two&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面示例中，通过?==锚定条件，指定只有在 \\w* 所能够匹配的字符后面跟随一个等号字符，才能够执行 \\w* 匹配。所以，最后匹配的字符串“two”，而不是字符串“one”。</p><h3 id="反向声明" tabindex="-1"><a class="header-anchor" href="#反向声明" aria-hidden="true">#</a> 反向声明</h3><p>与正向声明匹配相反，指定接下来的字符都不必被匹配。语法格式如下：</p><p>匹配模式(?! 匹配条件)</p><p>下面代码定义一个反前向生命的匹配模式。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;one : 1; two : 2&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\w*(?!=)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">//使用正前向声明，指定执行匹配不必满足的条件</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;one&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面示例中，通过?!=锚定条件，指定只有在“\\w*”所能够匹配的字符后面不跟随一个等号字符，才能够执行 \\w*匹配。所以，最后匹配的是字符串“one”，而不是字符串“two”。</p><h2 id="表达式分组" tabindex="-1"><a class="header-anchor" href="#表达式分组" aria-hidden="true">#</a> 表达式分组</h2><p>使用小括号可以对字符模式进行任意分组，在小括号内的字符串表示为表达式分组。表达式分组具有独立的匹配功能，保存独立的匹配结果；同时，小括号后的量词将会作用于整个表达式分组。</p><p>通过分组可以在一个完整的字符模式中定义一个或多个表达式分组。当正则表达式成功地匹配目标字符串后，也可以从目标字符串中抽出与表达式分组相匹配的子内容。</p><p>示例</p><p>在下面代码中，不仅能匹配出每个变量声明，同时还抽出每个变量及其值。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;ab=21, bc=45, cd=43&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\\w+)=(\\d*)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回类似[&quot;ab=21&quot;,&quot;bc=45&quot;,&quot;cd=43&quot;]三个数组</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="反向引用" tabindex="-1"><a class="header-anchor" href="#反向引用" aria-hidden="true">#</a> 反向引用</h2><p>在字符模式中，后面的字符可以引用前面的表达式分组。实现方法如下：</p><p>+ 数字</p><p>数字指定了表达式分组在字符模式中的顺序。如“\\1”引用的是第 1 个表达式分组，“\\2”引用的是第 2 个表达式分组。</p><p>示例 1</p><p>在下面代码中，通过引用前面表达式分组匹配的文本，实现成组匹配字符串。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;&lt;h1&gt;title&lt;h1&gt;&lt;p&gt;text&lt;p&gt;&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(&lt;\\w+&gt;\\w+&lt;\\/?\\w+&gt;)|1</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;&lt;h1&gt;title&lt;h1&gt;&quot;,&quot;&lt;p&gt;text&lt;p&gt;&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于表达式分组可以相互嵌套，它们的顺序将根据左括号的顺序来确定。例如，下面示例定义匹配模式包含多个表达式分组。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(a(b(c)))</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;abc&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;c&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个模式中，共产生了 3 个反向引用，第一个是“(a(b(c)))”，第二个是“(b(c))”，第三个是“(C)”。它们引用的匹配文本分别是字符串“abc”、“bc”和“c”。</p><p>对表达式分组的引用，是指引用前面表达式分组所匹配的文本，而不是表达式分组的匹配模式。如果要引用前面表达式分组的匹配模式，则必须使用下面方式，只有这样才能够达到匹配目的。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;&lt;h1&gt;title&lt;/h1&gt;&lt;p&gt;text&lt;/p&gt;&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(&lt;\\w+&gt;\\w+&lt;\\/?\\w+&gt;).*(&lt;\\w+&gt;\\w+&lt;\\/?\\w+&gt;)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组[&quot;&lt;h1&gt;title&lt;/h1&gt;&quot;,&quot;&lt;p&gt;text&lt;/p&gt;&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反向引用在开发中主要有以下几种常规用法。</p><p>示例 2</p><p>在正则表达式对象的 test() 方法中，以及字符串对象的 match() 和 search() 等方法中使用。在这些方法中，反向引用的值可以从 RegExp() 构造函数中获得。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;abcdefghijklmn&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\\w)(\\w)(\\w)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
r<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回第1个表达式分组匹配的字符a</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回第2个表达式分组匹配的字符b</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>RegExp<span class="token punctuation">.</span>$3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回第3个表达式分组匹配的字符c</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面示例可以看到，正则表达式执行匹配检测后，所有表达式分组匹配的文本都被分组存储在 RegExp() 构造函数的属性内，通过前缀符号$与正则表达式中表达式分组的编号来引用这些临时属性。其中属性 $1 标识符指向第 1 个值引用，属性 $2 标识符指向第 2 个值引用。</p><p>示例 3</p><p>可以直接在定义的字符模式中包含反向引用。这可以通过使用特殊转义序列（如 \\1、\\2 等）来实现。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;abcbcacba&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\\w)(\\w)(\\w)\\2\\3\\1\\3\\2\\1</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//验证正则表达式是否匹配该字符串</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面示例的正则表达式中，“\\1”表示对第 1 个反向引用 (\\w) 所匹配的字符 a 进行引用，“\\2”表示对第 2 个反向引用 (\\w) 所匹配的字符串 b 进行引用，“\\3”表示对第 3 个反向引用 (\\w) 所匹配的字符 c 进行引用。</p><p>示例 4</p><p>可以在字符串对象的 replace() 方法中使用。通过使用特殊字符序列$1、$2、$3 等来实现。例如，在下面的示例中将颠倒相邻字母和数字的位置。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;aa11bb22c3d4e5f6&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\\w+?)(\\d+)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">&quot;$2$1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回字符串“aa11bb22c3  d4e5f6”</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面例子中，正则表达式包括两个分组，第 1 个分组匹配任意连续的字母，第 2 个分组匹配任意连续的数字。在 replace() 方法的第 2 个参数中，$1 表示对正则表达式中第 1 个表达式分组匹配文本的引用，而 $2 表示对正则表达式中第 2 个表达式分组匹配文本的引用，通过颠倒 $1 和 $2 标识符的位置，即可实现字符串的颠倒来替换原字符串。</p><h2 id="禁止引用" tabindex="-1"><a class="header-anchor" href="#禁止引用" aria-hidden="true">#</a> 禁止引用</h2><p>反向引用会占用一定的系统资源，在较长的正则表达式中，反向引用会降低匹配速度。如果分组仅仅是为了方便操作，可以禁止反向引用。</p><p>实现方法：在左括号的后面加上一个问号和冒号。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?:\\w*?)|(?:\\d*?)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>非引用型分组必须使用表达式分组，但是又不希望存储无用的匹配信息，或者希望提高匹配速度来说，是非常重用的方法。</p>`,100);function g(v,m){const e=r("CodeDemo");return p(),o("div",null,[u,l(e,{id:"code-demo-349",type:"normal",title:"%E9%80%89%E6%8B%A9%E6%A8%A1%E5%BC%8F",code:"eJx9kl9P01AYxr/K6zFxW7QtcGWkLDHeeKFXcufxoilnsGTr6ump0SAXJJApSqYR/IOLbjr+XDBGQkjGGN2X2Tkd34L30A0ICSRt0z49z6993ufMkzlRLJBHxL5jGOCWZpjPvH67KSst9Xczrn5Szf+y3Y6Pv6k/VTCMLPVsH9yCEwRTlPjjlGRty7+mTlyqgcvzvsA7gDcOhwCmIGUXmXDAnXN4wASuD0XOeIiW1CRYloyWB72yOm7EG0uD+o5cXVeVL/1Oo9+rq8XWiMORY1Gaek8pJXix8cxas3lNSOxy+eB0bU82f8S7W4jSMT78QuAgimS3ojm50HNFvuRBLp2Bea0AutXvnlr9J8snan1/pKG6snIVmCzqtzuydSQ7a8iPT76e1g/VzyhudPRj93tcW1S17vBbAJyJkHtAyb27lMB9cPhsWGSeCF6OvTL1LJ7g7B+L9FgGX1IyqQ80LowSO5g4MDnzC47L0vwB5DI6rPq4Pah/TiInf6UNMyX3HG6+Dhl/94IVmCtKPE2JqRvLmHnPY/zp9PNnCHXOp17d8cex9iTAsPONpWHaWjluRpcF3ELH5of0afZWXKVP3EQfcW3rYq+QhTM1qjXD"},{default:c(()=>[d]),_:1}),k])}const h=t(i,[["render",g],["__file","正则表达式.html.vue"]]);export{h as default};
