import{_ as a,Y as n,Z as s,a1 as e}from"./framework-bb209140.js";const p={},t=e(`<p>随着现在后端编程标准化程度越来越高，各种编程模型层出不穷，这里将这些概念拆分开详细讲解一下，力求有一个清晰的理解，能在开发中有所助益。</p><p>下面的编程模型与模式，以Java为参考标准。</p><h2 id="dao" tabindex="-1"><a class="header-anchor" href="#dao" aria-hidden="true">#</a> DAO</h2><p>DAO（<strong>Data Access Object</strong>）是一种设计模式，用于封装与数据源（如数据库或其他存储系统）交互的逻辑。DAO模式的主要目的是将数据访问逻辑与业务逻辑分离，使得业务逻辑不直接依赖于数据源，从而提高代码的可维护性和可扩展性。</p><p>DAO模式通常包含以下几个组件：</p><ol><li><p>数据访问接口（DAO接口）：定义了访问数据源的方法，例如增加、删除、修改和查询等操作。这些方法通常与特定的业务实体（如用户、订单等）相关。</p></li><li><p>数据访问实现类（DAO实现类）：实现DAO接口中定义的方法，包含与数据源交互的具体逻辑。例如，如果数据源是关系型数据库，DAO实现类可能包含SQL语句和JDBC代码。</p></li><li><p>业务实体（Entity）：表示业务逻辑中的实体对象，如用户、订单等。业务实体通常与数据源中的表或记录相对应。</p></li><li><p>数据传输对象（DTO）：用于在DAO和业务逻辑层之间传输数据。DTO通常是一个简单的Java对象，包含一组属性和相应的getter和setter方法。</p></li></ol><p>在实际开发中，可以使用DAO模式将数据访问逻辑与业务逻辑分离，从而使得业务逻辑不直接依赖于数据源。这样，当数据源发生变化时，只需要修改DAO实现类，而无需修改业务逻辑。同时，通过使用DAO接口和实现类，可以方便地为不同的数据源提供不同的实现，从而实现数据访问逻辑的可扩展性。</p><h2 id="整体概念" tabindex="-1"><a class="header-anchor" href="#整体概念" aria-hidden="true">#</a> 整体概念</h2><p>VO（<strong>View Object</strong>）：视图对象，也有人称之为值对象（<strong>Value Object</strong>）。用于展示层，通常用于表示一个值或一组值。例如，当一个应用程序需要表示一个订单或一个用户时，可以使用 VO 来表示这些对象。VO 通常包含一组相关的属性，以及一些用于操作这些属性的方法。VO 可以是不可变的，也可以是可变的，具体取决于应用程序的需要。</p><p>DTO（<strong>Data Transfer Object</strong>）：数据传输对象，通常用于在不同层之间传输数据。例如，当一个应用程序需要从数据库中检索数据时，可以使用 DTO 将数据从数据库层传输到业务逻辑层，然后再将数据传输到表示层（如 Web 层或移动应用程序层）。DTO 通常是一个纯数据对象，不包含任何业务逻辑，也不包含与数据库或其他数据源的直接交互。</p><p>BO（<strong>Business Object</strong>）：业务对象，把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。</p><p>PO（<strong>Persistent Object</strong>）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应 PO 的一个（或若干个）属性。</p><p>DO（<strong>Domain Object</strong>）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p><p>我们最常用的是 VO 和 DTO，常用于经典 MVC 架构之间的数据传输与转换。</p><h2 id="易混点一-vo-dto" tabindex="-1"><a class="header-anchor" href="#易混点一-vo-dto" aria-hidden="true">#</a> 易混点一：VO&amp;DTO</h2><p>视图对象，说白了它就是展示用的，不管展示方式是网页，还是客户端，还是 APP，只要是这个东西是让人看到的，我们就把它封装为 VO。</p><p>VO 比较容易混淆的是 DTO，DTO 是展示层与服务层之间传递数据的对象，可以这样说，对于绝大部分的应用场景来说，DTO 和 VO 的属性值基本是一致的，那么既然有了 VO，为什么还需要 DTO 呢？</p><p>我们来举例说明一下：</p><p>从服务层的 DTO 而言，一个用户的数据结构是这样的：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;gender&quot;</span><span class="token operator">:</span> <span class="token string">&quot;女&quot;</span><span class="token punctuation">,</span>
  &quot;age<span class="token operator">:</span> <span class="token number">25</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但客户端可能会存在多种表现：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;gender&quot;</span><span class="token operator">:</span> <span class="token string">&quot;女&quot;</span><span class="token punctuation">,</span>
  &quot;age<span class="token operator">:</span> <span class="token number">25</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;gender&quot;</span><span class="token operator">:</span> <span class="token string">&quot;女&quot;</span><span class="token punctuation">,</span>
  &quot;age<span class="token operator">:</span> <span class="token number">20</span>~<span class="token number">30</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，DTO 很有存在的必要，根据职责单一原则，服务层只负责业务，与具体的表现形式无关，DTO 不应该出现与表现形式的耦合，DTO 定义的是原始数据，VO 再对 DTO 数据进行解释。</p><h2 id="易混点二-bo-po" tabindex="-1"><a class="header-anchor" href="#易混点二-bo-po" aria-hidden="true">#</a> 易混点二：BO&amp;PO</h2><p>PO是持久化对象，这个很好理解，就是实体和数据库字段的对应，一个PO的数据结构对应库中表的结构，表中的一条记录就是一个PO属性，大多数情况下，PO仅仅作为PO只是用来增删改使用。</p><p>PO比较容易混淆的是BO，BO是业务对象，对应的是某个具体的业务块，可以包含多个属性、对象。简单点来说，我们可以把BO看作是PO的组合。</p><p>我们来举例说明一下：</p><p>PO-1是交易记录对象，PO-2是登录记录对象，PO-3是商品浏览记录对象，PO-4是添加购物车记录对象，PO-5是搜索记录对象，BO是个人网站行为对象，BO对象：{PO-1;PO-2;PO-3;PO-4;PO-5}。这样做的优点不言而喻，维护代码的时候查看BO，就能知道这块逻辑涉及多少表（PO）。</p><h2 id="易混点三-bo-dto" tabindex="-1"><a class="header-anchor" href="#易混点三-bo-dto" aria-hidden="true">#</a> 易混点三：BO&amp;DTO</h2><p>搞清楚了BO和PO各自用途后，我们会发现BO和DTO存在功能重叠，一样可以对PO进行排列组合，它们又有什么区别呢？</p><p>它们从用途上存在根本的区别，BO是业务对象，DTO是数据传输对象，虽然BO也可以排列组合数据，但它的功能是对内的，比如上个例子中的BO对象包括{PO-1;PO-2;PO-3;PO-4;PO-5}还有其他字段属性，但在提供对外接口时，BO对象中的某些属性对象可能用不到或者不方便对外暴露，那么此时DTO只需要在BO的基础上，抽取自己需要的数据，然后对外提供。</p><p>在这个关系上，通常不会有数据内容的变化，内容变化要么在BO内部业务计算的时候完成，要么在解释VO的时候完成。</p><h2 id="do" tabindex="-1"><a class="header-anchor" href="#do" aria-hidden="true">#</a> DO</h2><p>DO是领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。事实上，DO和PO在绝大部分情况下是一一对应的。阿里巴巴的开发手册中的定义DO等同于PO，即与数据库表结构一一对应，通过DAO层向上传输数据源对象。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>一图流显示</p><figure><img src="https://misaka10032.oss-cn-chengdu.aliyuncs.com/midway/model.png" alt="数据模型一图流" tabindex="0" loading="lazy"><figcaption>数据模型一图流</figcaption></figure><p>VO，BO，PO，DTO这样分层还是很有意义的。尤其在团队成员较多的情况下，结构更加一目了然，同时也能很大程度避免多端系统数据所需不一致时，有人修改属性影响其他页面。但也完全没有必要教条主义，把这些全部用上，需要根据所开发的业务复杂度来取舍，如果本身业务逻辑不负责，照搬全上反而让开发变的更复杂。</p><p>例如业务不复杂，根本没有多端展示的差异化，VO可以直接拿掉，直接使用DTO传输到前端数据即可。</p><p>同时在使用过程中，最重要的是要在团队中达成共识，概念一致，如果使用了这些，但各按各的理解来，甚至抓起来就直接用，反而会让代码变得更乱。</p><p>另附这些概念命名规范：</p><ul><li>数据对象：xxxPO，xxx即为数据表名。(也可DO)</li><li>数据传输对象：xxxDTO，xxx为业务领域相关的名称。</li><li>展示对象：xxxVO，xxx一般为网页名称。</li><li>业务对象：xxxBO，xxx是业务名称。</li></ul>`,43),o=[t];function i(r,O){return n(),s("div",null,o)}const l=a(p,[["render",i],["__file","1-model.html.vue"]]);export{l as default};
