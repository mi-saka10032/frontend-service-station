import{_ as r}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as t,b as d,e,d as h,w as l,a as n,r as o}from"./app.08b485aa.js";const c={},p=n('<h2 id="模块" tabindex="-1"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h2><p>向外提供特定功能的 JS 程序，一般就是一个 JS 文件</p><p>为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂</p><p>作用：复用 JS，简化 JS 的编写，提高 JS 运行效率</p><h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件" aria-hidden="true">#</a> 组件</h2><p>用来实现局部功能效果的代码和资源的集合(html/css/js/image 等)</p><p>为什么要用组件：一个界面的功能更复杂</p><p>作用：复用编码，简化项目编码，提高运行效率</p><h2 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h2><p>当应用的 JS 都以模块来编写的, 这个应用就是一个模块化的应用</p><h2 id="组件化" tabindex="-1"><a class="header-anchor" href="#组件化" aria-hidden="true">#</a> 组件化</h2><p>当应用是以多组件的方式实现, 这个应用就是一个组件化的应用</p><h3 id="功能界面的组件化编码流程-通用" tabindex="-1"><a class="header-anchor" href="#功能界面的组件化编码流程-通用" aria-hidden="true">#</a> 功能界面的组件化编码流程（通用）</h3><ol><li>拆分组件：拆分界面、抽取组件</li><li>实现静态组件：使用组件实现静态页面效果</li><li>实现动态组件：动态显示初始化数据 <ol><li>数据类型</li><li>数据名称</li><li>保存在哪个组件</li></ol></li><li>交互（绑定事件监听开始）</li></ol><h3 id="组件书写规范" tabindex="-1"><a class="header-anchor" href="#组件书写规范" aria-hidden="true">#</a> 组件书写规范</h3><ol><li>组件名必须首字母大写</li><li>虚拟 DOM 元素只能有一个根元素</li><li>虚拟 DOM 元素必须有结束标签</li></ol><h3 id="渲染类组件标签基本流程" tabindex="-1"><a class="header-anchor" href="#渲染类组件标签基本流程" aria-hidden="true">#</a> 渲染类组件标签基本流程</h3><p>React 内部会创建组件实例对象</p><p>调用 render()得到虚拟 DOM，并解析为真实 DOM</p><p>插入到指定的页面元素内部</p><p>执行了 ReactDOM.render 之后发生了什么：</p><p>React 解析组件标签，找到 Component 组件</p><p>发现组件是使用类定义的，随后 new 该类的实例对象，并通过该实例调用到原型上的 render 方法</p><p>将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中</p>',24);function s(_,u){const a=o("RouterLink");return i(),t("div",null,[d("p",null,[e("此处内容与"),h(a,{to:"/vue2/6-%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html"},{default:l(()=>[e("Vue2 组件化编程")]),_:1}),e("大同小异，仅作 React 学习记录用")]),p])}const x=r(c,[["render",s],["__file","3-模块化与组件化.html.vue"]]);export{x as default};
