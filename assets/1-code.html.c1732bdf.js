import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as e,a}from"./app.c9ae6438.js";const r={},t=a('<h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><p>JS 中的内存管理遵循：申请内存空间 -&gt; 使用内存空间 -&gt; 释放内存空间 的顺序</p><p>垃圾回收机制：</p><ol><li>JS 自动进行内存管理</li><li>对象不再被引用时就是垃圾</li><li>对象不能从根（全局变量对象）上访问的时候就是垃圾</li></ol><p>下面的垃圾回收算法都按照这个机制执行垃圾回收</p><h2 id="垃圾回收-gc-算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收-gc-算法" aria-hidden="true">#</a> 垃圾回收(GC)算法</h2><p>GC可以找到内存中的垃圾，并释放和回收空间</p><p>优点：</p><ul><li>发现垃圾立即回收</li><li>最大限度地减少程序暂停</li></ul><p>缺点：</p><ul><li>循环引用对象无法回收</li><li>时间开销大（时刻维护对象的引用）</li></ul><p>常用的GC算法如下。</p><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><p>维护一个引用计数器，判断当前引用数是否为0</p><p>引用数字为0的时候立即回收</p><p>互相引用的对象无法被回收</p><p>优缺点：</p><ul><li>可以即时回收垃圾对象</li><li>减少程序卡顿时间</li><li>无法回收循环引用的对象</li><li>资源消耗较大</li></ul>',18),p=[t];function c(o,d){return l(),e("div",null,p)}const s=i(r,[["render",c],["__file","1-code.html.vue"]]);export{s as default};
