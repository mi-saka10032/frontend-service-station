import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as e,a as l}from"./app.e61d181b.js";const p={},r=l('<h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><p>JS 中的内存管理遵循：申请内存空间 -&gt; 使用内存空间 -&gt; 释放内存空间 的顺序</p><p>垃圾回收机制：</p><ol><li>JS 自动进行内存管理</li><li>对象不再被引用时就是垃圾</li><li>对象不能从根（全局变量对象）上访问的时候就是垃圾</li></ol><p>下面的垃圾回收算法都按照这个机制执行垃圾回收</p><h3 id="垃圾回收-gc-算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收-gc-算法" aria-hidden="true">#</a> 垃圾回收(GC)算法</h3><p>GC 可以找到内存中的垃圾，并释放和回收空间</p><p>优点：</p><ul><li>发现垃圾立即回收</li><li>最大限度地减少程序暂停</li></ul><p>缺点：</p><ul><li>循环引用对象无法回收</li><li>时间开销大（时刻维护对象的引用）</li></ul><p>常用的 GC 算法如下。</p><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><p>维护一个引用计数器，判断当前引用数是否为 0</p><p>引用数字为 0 的时候立即回收</p><p>互相引用的对象无法被回收</p><p>优缺点：</p><ul><li>可以即时回收垃圾对象</li><li>减少程序卡顿时间</li><li>无法回收循环引用的对象</li><li>资源消耗较大</li></ul><h3 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h3><p>分标记阶段和清除阶段两个阶段</p><p>遍历所有对象找标记活动对象</p><p>遍历所有对象清除没有标记对象</p><p>回收相应空间</p><p>优缺点：</p><ul><li>相对于引用计数，可以回收循环引用但没有用处的对象</li><li>内存空间地址不连续、空间碎片化，由于回收的对象在本来的地址也是不连续的，就会导致回收的对象地址也是不连续的，浪费空间</li><li>不会立即回收垃圾对象</li></ul><h3 id="标记整理" tabindex="-1"><a class="header-anchor" href="#标记整理" aria-hidden="true">#</a> 标记整理</h3><p>标记清除的增强版</p><p>标记阶段的操作和标记清除一致</p><p><strong>清除阶段会先执行整理，移动对象位置</strong>，重点就是这个整理，标记清除就是因为回收的对象的地址不连续，导致碎片空间化。而标记整理会在清除前，先整理一遍，将活动的对象移动到一起，需要回收的对象移动到一起，这样回收的时候，回收对象的地址就是连续的。</p><p>优缺点：</p><ul><li>减少碎片化空间</li><li>不会立即回收垃圾对象</li></ul><h3 id="v8垃圾回收策略" tabindex="-1"><a class="header-anchor" href="#v8垃圾回收策略" aria-hidden="true">#</a> V8垃圾回收策略</h3><p>V8引擎采用的是分代回收</p><p>内存分为新生代存储区和老生代存储区，针对不同的对象采用不同的算法</p>',34),h=[r];function d(t,n){return a(),e("div",null,h)}const s=i(p,[["render",d],["__file","1-code.html.vue"]]);export{s as default};
