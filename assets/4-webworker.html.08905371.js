import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as o,b as s,e as p,d as r,a as n,r as l}from"./app.9dde53cf.js";const i={},c=n(`<p>众所周知，JS 是单线程没有多线程，当 JS 在页面中运行用时较长的同步任务的时候就会导致页面阻塞，从而我们需要把这些阻塞任务放在任务队列中</p><p>而实际上异步任务队列中的任务也并非多线程进行的，多个异步线程池里的异步任务也是顺序执行的，只是对于客户端而言不存在阻塞</p><p>然而现在，HTML5 提供了这样一个 API：Web Workers，允许我们在浏览器中执行多个线程的任务</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>Wob Worker 是 HTML5 标准的一部分，允许我们再 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力</p><p>因为是独立的线程，Worker 线程与 js 主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给 Worker 线程去处理，当 Worker 线程计算完成，再把结果返回给 js 主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。</p><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><h3 id="使用限制" tabindex="-1"><a class="header-anchor" href="#使用限制" aria-hidden="true">#</a> 使用限制</h3><p>worker 线程的使用有如下注意点：</p><ul><li>同源限制：执行的脚本文件路径不能跨域</li><li>文件限制：无法读取本地文件，加载的脚本必须来自网络</li><li>DOM 操作限制：worker 线程与主线程的 window 在不同的另一个全局上下文中运行，其中无法读取主线程的 DOM，也不能获取 document、window 等对象，但是可以获取 navigator、location、XMLHttpRequest、setTimeout 等浏览器 API</li><li>通信限制：双方线程不在同一个上下文，不能直接通信，需要通过 postMessage 方法通信</li><li>脚本限制：worker 线程不能执行 alert、confirm，但可以使用 XMLHttpRequest 对象发出 ajax 请求</li></ul><h3 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,12),d=s("thead",null,[s("tr",null,[s("th",{style:{"text-align":"left"}},"参数"),s("th",{style:{"text-align":"left"}},"说明")])],-1),u=s("tr",null,[s("td",{style:{"text-align":"left"}},"path"),s("td",{style:{"text-align":"left"}},"有效的 js 脚本的地址，必须遵守同源策略。无效的 js 地址或者违反同源策略，会抛出 SECURITY_ERR 类型错误")],-1),k=s("tr",null,[s("td",{style:{"text-align":"left"}},"options.type"),s("td",{style:{"text-align":"left"}},"可选，用以指定 worker 类型。该值可以是 classic 或 module。 如未指定，将使用默认值 classic")],-1),m=s("tr",null,[s("td",{style:{"text-align":"left"}},"options.credentials"),s("td",{style:{"text-align":"left"}},"可选，用以指定 worker 凭证。该值可以是 omit, same-origin，或 include。如果未指定，或者 type 是 classic，将使用默认值 omit (不要求凭证)")],-1),v={style:{"text-align":"left"}},h={href:"http://options.name",target:"_blank",rel:"noopener noreferrer"},b=s("td",{style:{"text-align":"left"}},"可选，在 DedicatedWorkerGlobalScope 的情况下，用来表示 worker 的 scope 的一个 DOMString 值，主要用于调试目的。",-1),f=n(`<h3 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h3><ul><li>worker.postMessage: 主线程往 worker 线程发消息，消息可以是任意类型数据，包括二进制数据</li><li>worker.terminate: 主线程关闭 worker 线程。主线程关闭后，连接立刻停止，主线程不再接收消息</li><li>worker.onmessage: 指定 worker 线程发消息时的回调，也可以通过 worker.addEventListener(&#39;message&#39;,cb)的方式</li><li>worker.onerror: 指定 worker 线程发生错误时的回调，也可以 worker.addEventListener(&#39;error&#39;,cb)</li><li>Worker 线程中全局对象为 self，代表子线程自身，这时 this 指向 self，其上有一些 api：</li></ul><p>Worker 线程中全局对象为 self，代表子线程自身，这时 this 指向 self，其上有一些 api：</p><ul><li>self.postMessage: worker 线程往主线程发消息，消息可以是任意类型数据，包括二进制数据</li><li>self.close: worker 线程关闭自己。不会直接断开与主线程连接，会等内部的 Event Loop 所有任务执行完后再关闭</li><li>self.onmessage: 指定主线程发 worker 线程消息时的回调，也可以 self.- addEventListener(&#39;message&#39;,cb)</li><li>self.onerror: 指定 worker 线程发生错误时的回调，也可以 self.addEventListener(&#39;error&#39;,cb)</li></ul><h3 id="通信数据" tabindex="-1"><a class="header-anchor" href="#通信数据" aria-hidden="true">#</a> 通信数据</h3><p>postMessage(message, transferList)方法接收两个参数，message 可以传递任何类型数据，包括对象，通信为拷贝关系，即是传值而非传址</p><p>Worker 对通信内容的修改也不会影响主线程，事实上浏览器内部的运行机制为，先将通信内容串行化，然后把串行化后的字符串发给 Worker 再还原</p><p>第二个参数 transferList，是一个可选数组，用于传递所有权。如果一个对象的所有权被转移，在发送它的上下文中将变为不可用。这个参数很少用</p><h2 id="引用-js" tabindex="-1"><a class="header-anchor" href="#引用-js" aria-hidden="true">#</a> 引用 js</h2><p>worker 线程中支持 importScripts() 方法加载我们需要的 js 文件，而且，通过此方法加载的 js 文件不受同源策略约束</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// utils.js</span>
<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// worker.js</span>
<span class="token function">importScripts</span><span class="token punctuation">(</span>&#39;<span class="token punctuation">.</span><span class="token operator">/</span>utils<span class="token punctuation">.</span>js<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="esm-模式" tabindex="-1"><a class="header-anchor" href="#esm-模式" aria-hidden="true">#</a> ESM 模式</h2><p>开启 module 模式后，让 worker.js 支持 ESM 文件导入</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// main.js（主线程）</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">&quot;/worker.js&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;module&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 指定 worker.js 的类型</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// utils.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// worker.js（worker线程）</span>
<span class="token keyword">import</span> add <span class="token keyword">from</span> <span class="token string">&quot;./utils.js&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 导入外部js</span>

self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// log 3</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> self<span class="token punctuation">;</span> <span class="token comment">// 只需把顶级对象self暴露出去即可</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h2><p>可传递的数据类型都基于结构化克隆算法，包括基本数据类型、复杂数据类型、文件类型、二进制类型等</p><p>不可传递的数据类型：Error、Function、DOM 节点、原型链属性等</p><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h2><ul><li>加密数据：有些加解密的算法比较复杂，或者在加解密很多数据的时候，这会非常耗费计算资源，导致 UI 线程无响应，因此这是使用 Web Worker 的好时机，使用 Worker 线程可以让用户更加无缝的操作 UI。</li><li>预取数据：有时候为了提升数据加载速度，可以提前使用 Worker 线程获取数据，因为 Worker 线程是可以是用 XMLHttpRequest 的。</li><li>预渲染：在某些渲染场景下，比如渲染复杂的 canvas 的时候需要计算的效果比如反射、折射、光影、材料等，这些计算的逻辑可以使用 Worker 线程来执行，也可以使用多个 Worker 线程，这里有个射线追踪的示例。</li><li>复杂数据处理：某些检索、排序、过滤、分析会非常耗费时间，这时可以使用 Web Worker 来进行，不占用主线程。</li><li>预加载图片：有时候一个页面有很多图片，或者有几个很大的图片的时候，如果业务限制不考虑懒加载，也可以使用 Web Worker 来加载图片，可以参考一下这篇文章的探索，这里简单提要一下。</li></ul>`,22);function g(w,j){const a=l("ExternalLinkIcon");return t(),o("div",null,[c,s("table",null,[d,s("tbody",null,[u,k,m,s("tr",null,[s("td",v,[s("a",h,[p("options.name"),r(a)])]),b])])]),f])}const y=e(i,[["render",g],["__file","4-webworker.html.vue"]]);export{y as default};
