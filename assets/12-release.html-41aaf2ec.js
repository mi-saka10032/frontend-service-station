import{_ as i,C as t,Y as l,Z as c,$ as e,a0 as a,a2 as n,a3 as d,a1 as o}from"./framework-bb209140.js";const p={},u=e("h2",{id:"二进制安装",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#二进制安装","aria-hidden":"true"},"#"),a(" 二进制安装")],-1),h={href:"http://crate.io",target:"_blank",rel:"noopener noreferrer"},m=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cargo</span> <span class="token function">install</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,1),v={href:"https://crates.io",target:"_blank",rel:"noopener noreferrer"},b=o(`<p>限制：只能安装具有二进制目标（binary target）的 crate</p><p>二进制目标 binary target：是一个可运行程序，由拥有 src/main.rs 或其它被指定为二进制文件的 crate 生成</p><p>通常：README 里有关于 crate 的描述：</p><ul><li>是否拥有 library target</li><li>是否拥有 binary target</li><li>或者两者都有</li></ul><p>cargo install 安装的二进制存放在根目录的 bin 文件夹</p><p>如果你用 rustup 安装的 Rust，没有任何自定义配置，那么二进制存放目录是<code>$HOME/.cargo/bin</code></p><p>使用前要注意确保该目录在环境变量<code>$PATH</code>中</p><h3 id="自定义命令扩展" tabindex="-1"><a class="header-anchor" href="#自定义命令扩展" aria-hidden="true">#</a> 自定义命令扩展</h3><p>cargo 被设计成可以使用子命令来扩展</p><p>如果<code>$PATH</code>中的某个二进制是<code>cargo-something</code>，你可以像子命令一样运行：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cargo</span> something
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>类似这样的自定义命令可以通过该命令列出：<code>cargo --list</code></p><p>优点：可使用 cargo install 来安装扩展，像内置工具一样来运行</p><h2 id="自定义构建" tabindex="-1"><a class="header-anchor" href="#自定义构建" aria-hidden="true">#</a> 自定义构建</h2><p>通过 release profile 自定义构建</p><p>release profile 是预定义的；可使用不同的配置，对代码编译拥有更多的控制</p><p>每个 profile 的配置都独立于其它的 profile</p><p>Cargo 主要的两个 profile：</p><ol><li>dev profile：适用于开发，<code>cargo build</code></li><li>release profile：适用于发布，<code>cargo build --release</code></li></ol><p>在<code>Cargo.toml</code>里添加<code>[profile.xxxx]</code>区域，在里面覆盖默认配置的子集</p><div class="language-toml line-numbers-mode" data-ext="toml"><pre class="language-toml"><code><span class="token punctuation">[</span><span class="token table class-name">profile.dev</span><span class="token punctuation">]</span>
<span class="token comment">## 默认是0</span>
<span class="token key property">opt-level</span> <span class="token punctuation">=</span> <span class="token number">1</span>

<span class="token punctuation">[</span><span class="token table class-name">profile.release</span><span class="token punctuation">]</span>
<span class="token comment"># 默认是3</span>
<span class="token key property">opt-level</span> <span class="token punctuation">=</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,21),k={href:"https://doc.rust-lang.org/cargo/",target:"_blank",rel:"noopener noreferrer"},g=o(`<h2 id="文档注释" tabindex="-1"><a class="header-anchor" href="#文档注释" aria-hidden="true">#</a> 文档注释</h2><p>文档注释用于</p><ul><li>生成 HTML 文档</li><li>显示公共 API 的文档注释：如何使用 API</li><li>使用<code>///</code></li><li>支持 Markdown</li><li>放置在被说明条目之前</li></ul><h3 id="文档命令" tabindex="-1"><a class="header-anchor" href="#文档命令" aria-hidden="true">#</a> 文档命令</h3><p>cargo doc：运行 rustdoc 工具（Rust 安装包自带），把生成的 HTML 文档放在<code>target/doc</code>目录下</p><p>cargo doc -open：构建当前 crate 的文档（也包含 crate 依赖项的文档），同时在浏览器打开文档</p><h3 id="常用章节" tabindex="-1"><a class="header-anchor" href="#常用章节" aria-hidden="true">#</a> 常用章节</h3><p><code>#Examples</code></p><p>其它常用章节：</p><ul><li>Panics：函数可能发生 panic 的场景</li><li>Errors：如果函数返回 Result，描述可能的错误种类，以及可导致错误的条件</li><li>Safety：如果函数处于 unsafe 调用，就应该解释函数 unsafe 的原因，以及调用者确保的使用前提</li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token comment">/// Adds one to the number given.</span>
<span class="token comment">///</span>
<span class="token comment">/// # Examples</span>
<span class="token comment">///</span>
<span class="token comment">/// \`\`\`</span>
<span class="token comment">/// let arg = 5;</span>
<span class="token comment">/// let answer = my_crate::add_one(arg);</span>
<span class="token comment">///</span>
<span class="token comment">/// assert_eq!(6, answer);</span>
<span class="token comment">/// \`\`\`</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">add_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>
  x <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="测试文档注释" tabindex="-1"><a class="header-anchor" href="#测试文档注释" aria-hidden="true">#</a> 测试文档注释</h3><p>示例代码块的附加值：运行 cargo test 将把文档注释中的示例代码作为测试来运行</p><h3 id="注释项添加文档注释" tabindex="-1"><a class="header-anchor" href="#注释项添加文档注释" aria-hidden="true">#</a> 注释项添加文档注释</h3><p>符号：<code>//!</code></p><p>这类注释通常用来描述 crate 和模块，可以简单理解为文件头部注释：</p><ul><li>crate root（按管理 src/lib.rs）</li><li>一个模块内，将 crate 或模块作为一个整体进行记录</li></ul><h2 id="导出与发布" tabindex="-1"><a class="header-anchor" href="#导出与发布" aria-hidden="true">#</a> 导出与发布</h2><h3 id="快捷导出" tabindex="-1"><a class="header-anchor" href="#快捷导出" aria-hidden="true">#</a> 快捷导出</h3><p>使用 pub use 导出方便使用的公共 API</p><p>问题：crate 的程序结构在开发时对于开发者很合理，但对于它的使用者不够方便</p><p>开发者会把程序结构分为很多层，使用者想找到这种深层结构中的某个类型很费劲</p><p>例如：<code>my_crate:;some_module::another_module::UsefulType;</code></p><p>解决办法：</p><ul><li>不需要重新组织内部代码结构</li><li>使用 pub use：可以重新导出，创建一个与内部私有结构不同的对外公共结构</li></ul><h3 id="发布网站" tabindex="-1"><a class="header-anchor" href="#发布网站" aria-hidden="true">#</a> 发布网站</h3>`,26),_={href:"http://crates.io",target:"_blank",rel:"noopener noreferrer"},f={href:"https://crates.io/",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,"它会分发已注册的包的源代码，主要托管开源代码",-1),y={href:"http://crates.io",target:"_blank",rel:"noopener noreferrer"},C=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cargo</span> login <span class="token punctuation">[</span>你的API token<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你的 API token 存储在本地<code>~/.cargo/credentials</code></p><p>API token 可以在网站上撤销</p><h3 id="发布元数据" tabindex="-1"><a class="header-anchor" href="#发布元数据" aria-hidden="true">#</a> 发布元数据</h3><p>发布 crate 之前，需要在<code>Cargo.toml</code>的<code>[package]</code>区域为 crate 添加一些元数据：</p>`,5),A=e("li",null,"crate 需要唯一名称：name",-1),E=e("li",null,"description：一两句话即可，会出现在 crate 搜索的结果里",-1),w={href:"http://spdx.org/licenses/",target:"_blank",rel:"noopener noreferrer"},P=e("li",null,"version",-1),I=e("li",null,"author",-1),R=e("p",null,"发布命令：cargo publish",-1),L=e("p",null,"crate 一旦发布，就是用就行的，该版本无法覆盖，代码无法删除",-1),T=e("p",null,"目的：依赖于该版本的项目可继续正常工作",-1),q=e("h3",{id:"发布新版本",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#发布新版本","aria-hidden":"true"},"#"),a(" 发布新版本")],-1),H=e("p",null,[a("修改 crate 后，需要先修改"),e("code",null,"Cargo.toml"),a("里面的 version 值，再进行重新发布")],-1),M={href:"http://semver.org/",target:"_blank",rel:"noopener noreferrer"},B=o('<h3 id="撤回版本" tabindex="-1"><a class="header-anchor" href="#撤回版本" aria-hidden="true">#</a> 撤回版本</h3><p>虽然不可以删除 crate 之前的版本，但是可以防止其它项目把它作为新的依赖：yank(撤回) 一个 crate 版本</p><p>该操作是为了防止新项目依赖于该版本，同时已经存在的项目可继续将其作为依赖并可下载</p><p>yank 意味着：</p><ul><li>所有已经产生<code>Cargo.lock</code>的项目都不会中断</li><li>任何将来生成的<code>Cargo.lock</code>文件都不会使用被 yank 的版本</li></ul><p>命令：</p><ul><li>yank 一个版本（不会删除任何代码）：<code>cargo yank --vers 1.0.1</code></li><li>取消 yank：<code>cargo yank --vers 1.0.1 --undo</code></li></ul><h2 id="工作空间" tabindex="-1"><a class="header-anchor" href="#工作空间" aria-hidden="true">#</a> 工作空间</h2><p>cargo 工作空间：帮助管理多个相互关联且需要协同开发的 crate</p><p>cargo 工作空间是一套共享同一个<code>Cargo.lock</code>和输出文件夹的包</p>',10),N=o(`<h3 id="创建工作空间" tabindex="-1"><a class="header-anchor" href="#创建工作空间" aria-hidden="true">#</a> 创建工作空间</h3><p>有多重方式组件工作空间：1 个二进制 crate，2 个库 crate</p><ul><li>二进制 crate：main 函数，依赖于其它 2 个库 crate</li><li>其中 1 个库 crate 提供 add_one 函数</li><li>另外 1 个库 crate 提供 add_two 函数</li></ul><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code># 文件目录
|--- adder
|--- add-one
|--- Cargo.toml
|--- Cargo.lock
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-toml line-numbers-mode" data-ext="toml"><pre class="language-toml"><code><span class="token punctuation">[</span><span class="token table class-name">workspace</span><span class="token punctuation">]</span>

<span class="token key property">members</span> <span class="token punctuation">=</span> <span class="token punctuation">[</span>
  <span class="token string">&quot;adder&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;add-one&quot;</span>
<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="外部依赖" tabindex="-1"><a class="header-anchor" href="#外部依赖" aria-hidden="true">#</a> 外部依赖</h3><p>工作空间只有一个<code>Cargo.lock</code>文件，在工作空间的顶层目录</p><p>保证工作空间内所有 crate 使用的依赖版本都相同</p><p>保证工作空间内所有 crate 相互兼容</p>`,9);function V($,O){const s=t("ExternalLinkIcon"),r=t("RouterLink");return l(),c("div",null,[u,e("p",null,[a("从 "),e("a",h,[a("crate.io"),n(s)]),a(" 安装二进制 crate")]),m,e("p",null,[a("来源："),e("a",v,[a("https://crates.io"),n(s)])]),b,e("p",null,[a("默认值和完整选项，请参见："),e("a",k,[a("https://doc.rust-lang.org/cargo/"),n(s)])]),g,e("p",null,[e("a",_,[a("crates.io"),n(s)]),a(" 支持通过发布包来共享代码")]),e("p",null,[a("crates 的注册表在 "),e("a",f,[a("https://crates.io/"),n(s)])]),x,e("p",null,[a("发布 crate 前，需要在 "),e("a",y,[a("crates.io"),n(s)]),a(" 创建账号并获得 API token")]),C,e("ul",null,[A,E,e("li",null,[a("license：需提供许可证标识值（可到 "),e("a",w,[a("http://spdx.org/licenses/"),n(s)]),a(" 查找），可用 OR 指定多个 license")]),P,I]),R,L,T,q,H,e("p",null,[a("参照 "),e("a",M,[a("http://semver.org/"),n(s)]),a(" 来使用你的语义版本")]),B,e("p",null,[a("可理解为 Rust 的 "),n(r,{to:"/vcs/2-repo.html#monorepo%E6%96%B9%E6%A1%88"},{default:d(()=>[a("monorepo")]),_:1}),a(" 方案")]),N])}const D=i(p,[["render",V],["__file","12-release.html.vue"]]);export{D as default};
