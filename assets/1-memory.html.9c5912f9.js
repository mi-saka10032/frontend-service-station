import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as i,a as r}from"./app.aafd1c62.js";const h={},p=r('<h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2><p>JS 中的内存管理遵循：申请内存空间 -&gt; 使用内存空间 -&gt; 释放内存空间 的顺序</p><p>垃圾回收机制：</p><ol><li>JS 自动进行内存管理</li><li>对象不再被引用时就是垃圾</li><li>对象不能从根（全局变量对象）上访问的时候就是垃圾</li></ol><p>下面的垃圾回收算法都按照这个机制执行垃圾回收</p><h3 id="垃圾回收-gc-算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收-gc-算法" aria-hidden="true">#</a> 垃圾回收(GC)算法</h3><p>GC 可以找到内存中的垃圾，并释放和回收空间</p><p>优点：</p><ul><li>发现垃圾立即回收</li><li>最大限度地减少程序暂停</li></ul><p>缺点：</p><ul><li>循环引用对象无法回收</li><li>时间开销大（时刻维护对象的引用）</li></ul><p>常用的 GC 算法如下。</p><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><p>维护一个引用计数器，判断当前引用数是否为 0</p><p>引用数字为 0 的时候立即回收</p><p>互相引用的对象无法被回收</p><p>优缺点：</p><ul><li>可以即时回收垃圾对象</li><li>减少程序卡顿时间</li><li>无法回收循环引用的对象</li><li>资源消耗较大</li></ul><h3 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h3><p>分标记阶段和清除阶段两个阶段</p><p>遍历所有对象找标记活动对象</p><p>遍历所有对象清除没有标记对象</p><p>回收相应空间</p><p>优缺点：</p><ul><li>相对于引用计数，可以回收循环引用但没有用处的对象</li><li>内存空间地址不连续、空间碎片化，由于回收的对象在本来的地址也是不连续的，就会导致回收的对象地址也是不连续的，浪费空间</li><li>不会立即回收垃圾对象</li></ul><h3 id="标记整理" tabindex="-1"><a class="header-anchor" href="#标记整理" aria-hidden="true">#</a> 标记整理</h3><p>标记清除的增强版</p><p>标记阶段的操作和标记清除一致</p><p><strong>清除阶段会先执行整理，移动对象位置</strong>，重点就是这个整理，标记清除就是因为回收的对象的地址不连续，导致碎片空间化。而标记整理会在清除前，先整理一遍，将活动的对象移动到一起，需要回收的对象移动到一起，这样回收的时候，回收对象的地址就是连续的。</p><p>优缺点：</p><ul><li>减少碎片化空间</li><li>不会立即回收垃圾对象</li></ul><h2 id="v8-垃圾回收策略" tabindex="-1"><a class="header-anchor" href="#v8-垃圾回收策略" aria-hidden="true">#</a> V8 垃圾回收策略</h2><p>V8 引擎采用的是分代回收</p><p>内存分为新生代存储区和老生代存储区，针对不同的对象采用不同的算法</p><p>V8 中常用的 GC：<strong>分代回收、空间复制、标记清除、标记整理、标记增量</strong></p><h3 id="新生代处理" tabindex="-1"><a class="header-anchor" href="#新生代处理" aria-hidden="true">#</a> 新生代处理</h3><h4 id="新生代对象回收" tabindex="-1"><a class="header-anchor" href="#新生代对象回收" aria-hidden="true">#</a> 新生代对象回收</h4><p>V8 将内存空间一分为二</p><p>小空间用于存储新生代对象（32M | 16M）</p><p>新生代对象指的是存活时间较短的对象</p><h4 id="新生代对象回收实现" tabindex="-1"><a class="header-anchor" href="#新生代对象回收实现" aria-hidden="true">#</a> 新生代对象回收实现</h4><p>回收过程采用复制算法+标记整理</p><p>新生代内存区分为两个等大小空间</p><p>使用空间为 from，空闲空间为 to</p><p>活动对象存储于 from 空间</p><p>标记整理后将活动对象拷贝至 to 空间</p><p>from 与 to 交换空间完成释放</p><h4 id="回收细节说明" tabindex="-1"><a class="header-anchor" href="#回收细节说明" aria-hidden="true">#</a> 回收细节说明</h4><p>拷贝过程中可能出现晋升</p><p>晋升就是将新生代对象移动至老生代</p><p>一轮 GC 还存活的新生代就需要晋升</p><p>to 空间的使用率超过 25%</p><h3 id="老生代处理" tabindex="-1"><a class="header-anchor" href="#老生代处理" aria-hidden="true">#</a> 老生代处理</h3><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h4>',54),d=[p];function l(t,n){return e(),i("div",null,d)}const s=a(h,[["render",l],["__file","1-memory.html.vue"]]);export{s as default};
