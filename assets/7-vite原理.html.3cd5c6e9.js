import{_ as c}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as l,a as s,b as n,e as a,w as u,d as p,r as t}from"./app.5f8837b7.js";const r={},d=s("h2",{id:"冷启动链路",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#冷启动链路","aria-hidden":"true"},"#"),n(" 冷启动链路")],-1),k=s("p",null,"现在分析执行 vite 命令后 vite 的启动流程",-1),v={href:"https://blog.csdn.net/qq_40716795/article/details/122975260",target:"_blank",rel:"noopener noreferrer"},m=p(`<h3 id="命令解析" tabindex="-1"><a class="header-anchor" href="#命令解析" aria-hidden="true">#</a> 命令解析</h3><p>这部分代码在 src/node/cli.ts 里，主要内容是借助 minimist —— 一个轻量级的命令解析工具解析 npm scripts，解析的函数是 resolveOptions ，精简后的代码片段如下</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">resolveOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// command 可以是 dev/build/optimize</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">.</span>_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    argv<span class="token punctuation">.</span>command <span class="token operator">=</span> argv<span class="token punctuation">.</span>_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> argv<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>拿到 options 后，会根据 options.command 的值判断是执行在开发环境需要的 runServe 命令或生产环境需要的 runBuild 命令</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>command <span class="token operator">||</span> options<span class="token punctuation">.</span>command <span class="token operator">===</span> <span class="token string">&quot;serve&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">runServe</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>command <span class="token operator">===</span> <span class="token string">&quot;build&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">runBuild</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>command <span class="token operator">===</span> <span class="token string">&quot;optimize&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">runOptimize</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 runServe 方法中，执行 server 模块的创建开发服务器方法，同样在 runBuild 中执行 build 模块的构建方法</p><h3 id="runserve" tabindex="-1"><a class="header-anchor" href="#runserve" aria-hidden="true">#</a> runServe</h3><p>这部分代码在 src/node/server/index.ts 里，主要暴露一个 createServer 方法。</p><p>vite 使用 koa 作 web server，使用 clmloader 创建了一个监听文件改动的 watcher，同时实现了一个插件机制，将 koa-app 和 watcher 以及其他必要工具组合成一个 context 对象注入到每个 plugin 中</p><p><img src="https://misaka10032.oss-cn-chengdu.aliyuncs.com/Webpack/vite-context.png" alt="ViteContext" loading="lazy"></p><h3 id="plugin" tabindex="-1"><a class="header-anchor" href="#plugin" aria-hidden="true">#</a> plugin</h3><p>plugin 依次从 context 里获取上面这些组成部分，有的 plugin 在 koa 实例添加了几个 middleware，有的借助 watcher 实现对文件的改动监听，这种插件机制带来的好处是整个应用结构清晰，同时每个插件处理不同的事情，职责更分明</p><p>默认的 plugin 有：</p><ul><li><p>用户注入的 plugins —— 自定义 plugin</p></li><li><p>hmrPlugin —— 处理 hmr</p></li><li><p>htmlRewritePlugin —— 重写 html 内的 script 内容</p></li><li><p>moduleRewritePlugin —— 重写模块中的 import 导入</p></li><li><p>moduleResolvePlugin ——获取模块内容</p></li><li><p>vuePlugin —— 处理 vue 单文件组件</p></li><li><p>esbuildPlugin —— 使用 esbuild 处理资源</p></li><li><p>assetPathPlugin —— 处理静态资源</p></li><li><p>serveStaticPlugin —— 托管静态资源</p></li><li><p>cssPlugin —— 处理 css/less/sass 等引用</p></li></ul><p>所以，plugin 在开发模式下的运行机制实际上就是 koa 的中间件；在生产模式下则略有不同，它们是作为 rollup 打包的 plugin</p><h3 id="esm" tabindex="-1"><a class="header-anchor" href="#esm" aria-hidden="true">#</a> ESM</h3><p>Vite 借助浏览器对 ES Module 的支持，让浏览器直接引入模块化文件</p><p>打开运行中的 Vite 项目，访问 view-source 可以发现 html 里面的代码是这样的：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;/@modules/vue&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">&quot;/App.vue&quot;</span><span class="token punctuation">;</span>
  <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">&quot;#app&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可获知的消息，浏览器环境从：</p><ol><li><code>/@modules/vue</code> 中获取 createApp 这个方法</li><li><code>App.vue</code> 中获取应用组件入口</li><li>使用 createApp 创建应用并挂载节点</li></ol><p>而这样做达成的效果是：</p><ol><li>去掉了打包步骤</li><li>实现按需加载模块文件</li></ol><h4 id="去掉打包步骤" tabindex="-1"><a class="header-anchor" href="#去掉打包步骤" aria-hidden="true">#</a> 去掉打包步骤</h4><p>原本 Webpack 打包的概念是将各个模块集合在一起形成 bundle，以一定规则读取模块代码——以便在不支持模块化的浏览器中使用。在开发环境下，bundle 文件处在内存中，生产环境是静态的 js 文件</p><p>为了在浏览器里加载各个模块，Webpack 会使用 map 存放模块 id 和路径，使用<code>__webpack_require__</code>方法获取模块导出</p><p>Vite 利用浏览器支持 ESM 这一点，省略了这一步，自然就不需要生成 bundle，因此打包这一步就省略了</p><h4 id="实现按需打包" tabindex="-1"><a class="header-anchor" href="#实现按需打包" aria-hidden="true">#</a> 实现按需打包</h4><p>因为打包过程是静态的，不管某个模块的代码是否执行到，执行打包到这个模块的时候，都会打包进 bundle 中，因此项目越来越大 bundle 也会越来越大</p><p>而 Vite 直接使用 ESM，在上文提到的 runServer 中，通过 koa 服务器劫持本地资源内容返回到服务器，让浏览器按需获取模块内容</p><h3 id="返回编译模块" tabindex="-1"><a class="header-anchor" href="#返回编译模块" aria-hidden="true">#</a> 返回编译模块</h3><p>在上面的 ESM 中，我们从浏览器引入了<code>/@modules/vue</code>这个 node_modules 中的 vue 依赖，以及<code>/App.vue</code>这个组件</p><p>下一步，在下一个 koa 的 middleware 中</p><ol><li>用正则匹配到路径上带有<code>@modules</code>的资源，再通过<code>require(&#39;xxx&#39;)</code>的形式拿到依赖的导出返回给浏览器</li><li>匹配路径上带有<code>.vue</code>的资源，使用 vuePlugin 处理，执行模板编译后导出返回给浏览器</li></ol>`,34),b={href:"https://blog.csdn.net/qq_40716795/article/details/122975260",target:"_blank",rel:"noopener noreferrer"},h=p(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> updateStyle <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;/vite/hmr&quot;</span><span class="token punctuation">;</span>
<span class="token function">updateStyle</span><span class="token punctuation">(</span><span class="token string">&quot;c44b8200-0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/App.vue?type=style&amp;index=0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
__script<span class="token punctuation">.</span>__scopeId <span class="token operator">=</span> <span class="token string">&quot;data-v-c44b8200&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> render <span class="token keyword">as</span> __render <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;/App.vue?type=template&quot;</span><span class="token punctuation">;</span>
__script<span class="token punctuation">.</span>render <span class="token operator">=</span> __render<span class="token punctuation">;</span>
__script<span class="token punctuation">.</span>__hmrId <span class="token operator">=</span> <span class="token string">&quot;/App.vue&quot;</span><span class="token punctuation">;</span>
__script<span class="token punctuation">.</span>__file <span class="token operator">=</span> <span class="token string">&quot;/Users/muou/work/playground/vite-app/App.vue&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> __script<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以一个 Vue 文件最后返回到浏览器的响应结果是分次返回的</p><p><img src="https://misaka10032.oss-cn-chengdu.aliyuncs.com/Webpack/vite-import-Appvue.png" alt="Vite浏览器导入App.vue" loading="lazy"></p><p>到这里，冷启动的步骤就算结束了。接下来，是浏览器结合之前导入的 vue.js 和分拆的 App.vue 的代码，执行 Vue 的实例化并挂载组件的时间了</p><h2 id="热更新" tabindex="-1"><a class="header-anchor" href="#热更新" aria-hidden="true">#</a> 热更新</h2><p>一般来说，通用的热更新实现分四步：</p><ol><li>打通 web 框架，让模块支持 rerender/reload</li><li>通过 watcher 监听文件改动</li><li>通过 server 端编译资源，推送新模块内容给 client</li><li>client 收到新的模块内容，执行 rerender/reload</li></ol><h3 id="client" tabindex="-1"><a class="header-anchor" href="#client" aria-hidden="true">#</a> client</h3><p>在客户端，Vite 开启了 WebSocket 监听了一些更新的类型，然后分别处理，分别是：</p><ul><li><p>vue-reload —— vue 组件更新：通过 import 导入新的 vue 组件，然后执行 HMRRuntime.reload</p></li><li><p>vue-rerender —— vue template 更新：通过 import 导入新的 template ，然后执行 HMRRuntime.rerender</p></li><li><p>vue-style-update —— vue style 更新：直接插入新的 stylesheet</p></li><li><p>style-update —— css 更新：document 插入新的 stylesheet</p></li><li><p>style-remove —— css 移除：document 删除 stylesheet</p></li><li><p>js-update —— js 更新：直接执行</p></li><li><p>full-reload —— 页面 roload：使用 window.reload 刷新页面</p></li></ul><h3 id="server" tabindex="-1"><a class="header-anchor" href="#server" aria-hidden="true">#</a> server</h3><p>在 server 端，通过之前说过的已开启的 watcher 监听项目结构、内容改动，根据文件类型判断是 js Reload 还是 vue Reload</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>watcher<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;change&quot;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">file</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> timestamp <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&quot;.vue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleVueReload</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
    file<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&quot;.module.css&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token operator">!</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&quot;.css&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span> cssTransforms<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> t<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// everything except plain .css are considered HMR dependencies.</span>
    <span class="token comment">// plain css has its own HMR logic in ./serverPluginCss.ts.</span>
    <span class="token function">handleJSReload</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 handleVueReload 方法里，会使用解析器拿到当前文件的 template/script/style ，并且与缓存里的上一次解析的结果进行比较，如果 template 发生改变就执行 vue-rerender，如果 style 发生改变就执行 vue-style-update，简化后的逻辑如下</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handleVueReload</span><span class="token punctuation">(</span>
    <span class="token parameter">file
    timestamp<span class="token punctuation">,</span>
    content</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取缓存</span>
    <span class="token keyword">const</span> cacheEntry <span class="token operator">=</span> vueCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>

    <span class="token comment">// 解析 vue 文件</span>
    <span class="token keyword">const</span> descriptor <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">parseSFC</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> file<span class="token punctuation">,</span> content<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>descriptor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// read failed</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 拿到上一次解析结果</span>
    <span class="token keyword">const</span> prevDescriptor <span class="token operator">=</span> cacheEntry <span class="token operator">&amp;&amp;</span> cacheEntry<span class="token punctuation">.</span>descriptor

    <span class="token comment">// 设置刷新变量</span>
    <span class="token keyword">let</span> needReload <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// script 改变标记</span>
    <span class="token keyword">let</span> needCssModuleReload <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// css 改变标记</span>
    <span class="token keyword">let</span> needRerender <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// template 改变标记</span>

    <span class="token comment">// 判断 script 是否相同</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>script<span class="token punctuation">,</span> prevDescriptor<span class="token punctuation">.</span>script<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      needReload <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>

     <span class="token comment">// 判断 template 是否相同</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>template<span class="token punctuation">,</span> prevDescriptor<span class="token punctuation">.</span>template<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      needRerender <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 通过 send 发送 socket</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>needRerender<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&#39;vue-rerender&#39;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">path</span><span class="token operator">:</span> publicPath<span class="token punctuation">,</span>
        timestamp
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>handleJSReload 方法则是根据文件路径引用，判断被哪个 vue 组件所依赖，如果未找到 vue 组件依赖，则判断页面需要刷新，否则走组件更新逻辑</p>`,16);function g(f,y){const o=t("RouterLink"),e=t("ExternalLinkIcon");return i(),l("div",null,[s("p",null,[n("Vite 在 dev 模式下执行的是 ESBuild 编译，build 时使用 rollup 编译。除了 Vite 把 loader 概念同化为 plugin 之外，其运作流程与 Webpack 基本类似，详见"),a(o,{to:"/webpack/4-webpack%E5%8E%9F%E7%90%86.html"},{default:u(()=>[n("Webpack 原理")]),_:1})]),d,k,s("p",null,[n("参考链接："),s("a",v,[n("https://blog.csdn.net/qq_40716795/article/details/122975260"),a(e)])]),m,s("p",null,[n("中间步骤暂时省略（详见"),s("a",b,[n("参考链接"),a(e)]),n("），我们直接看最后导出的代码：")]),h])}const q=c(r,[["render",g],["__file","7-vite原理.html.vue"]]);export{q as default};
